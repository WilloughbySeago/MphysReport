% !TeX program = lualatex
\documentclass[fleqn]{NotesClass}

\strictpagecheck

%% Packages
\usepackage{csquotes}
\usepackage{tensor}
\usepackage{ytableau}
\ytableausetup{centertableaux}
\usepackage{microtype}

% Tikz stuff
\usepackage{tikz}
% External
\usetikzlibrary{external}
\tikzexternalize[prefix=tikz-external/]
% Other libraries
\usetikzlibrary{positioning}
\usetikzlibrary{decorations.markings}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{patterns}
\usetikzlibrary{calligraphy}

\usepackage{tikz-cd}

\RequirePackage[%
sorting=none,  % Don't sort the references, they will appear in the order they are first cited
style=numeric-comp,  % citations like [1] and citing 1, 2, and 3 gives [1-3]
giveninits=true,  % style author names as J. Doe
language=british  % Make dates dd/mm/yyyy
]{biblatex}
\addbibresource{ref.bib}
\usepackage{xurl}

% References, should be last things loaded
\usepackage[pdfauthor={Willoughby Seago},pdftitle={MPhys Report: Computational Group Theory},pdfkeywords={group theory, representation theory, birdtracks, Lie theory},pdfsubject={Lie Groups, Representation Theory}]{hyperref}  % Should be loaded second last (cleveref last)
\colorlet{hyperrefcolor}{blue!60!black}
\hypersetup{colorlinks=true, linkcolor=hyperrefcolor, urlcolor=hyperrefcolor, citecolor=hyperrefcolor}
\usepackage[
capitalize,
nameinlink,
noabbrev
]{cleveref} % Should be loaded last

% My packages
\usepackage{NotesBoxes}
\usepackage{NotesMaths}

\setmathfont[range={\int, \oint, \otimes, \oplus, \bigotimes, \bigoplus}]{Latin Modern Math}

% Highlight colour
\definecolor{highlight}{HTML}{710D78}
\definecolor{my blue}{HTML}{2A0D77}
\definecolor{my red}{HTML}{770D38}
\definecolor{my green}{HTML}{14770D}
\definecolor{my yellow}{HTML}{E7BB41}
\colorlet{light highlight}{highlight!30}
\colorlet{example background}{azure(web)(azuremist)!45}
\colorlet{background color}{white}

\AtBeginEnvironment{exm}{\colorlet{background color}{example background}}
\AtEndEnvironment{exm}{\colorlet{background color}{white}}

% Title page info
\title{Computational Group Theory}
\author{Willoughby Seago}
\date{March 27, 2023}
\subtitle{MPhys Project Report}
\subsubtitle{Supervised by Tony Kennedy}

% Commands
% Tikz
\tikzset{wire/.style={thick}}
\tikzset{underwire/.style={line width=1mm, background color}}
\tikzset{symmetriser/.style={fill=background color, thick, rounded corners=1pt}}
\tikzset{antisymmetriser/.style={fill=black, thick, rounded corners=1pt}}
\tikzset{wire arrow/.style={wire, postaction={decorate, decoration={markings, mark=at position #1 with {\arrow{stealth}}}}}}
\tikzset{wire arrow/.default=0.5}
\tikzset{wire arrow reversed/.style={wire, postaction={decorate, decoration={markings, mark=at position #1 with {\arrowreversed{stealth}}}}}}
\tikzset{wire arrow reversed/.default=0.5}
\tikzset{over wire/.style={wire, preaction={draw, background color, line width=#1}}}
\tikzset{over wire/.default={1.5mm}}
\tikzset{electron/.style={postaction={decorate, decoration={markings, mark=at position #1 with {\arrow{Latex[width=1.5mm]}}}}}}
\tikzset{electron/.default=0.5}
\tikzset{photon/.style={decoration={snake, amplitude=1.25, segment length=6}, decorate}}
\pgfdeclarepatternformonly{south west lines}{\pgfqpoint{-0pt}{-0pt}}{\pgfqpoint{3pt}{3pt}}{\pgfqpoint{3pt}{3pt}}{
    \pgfsetlinewidth{0.4pt}
    \pgfpathmoveto{\pgfqpoint{0pt}{0pt}}
    \pgfpathlineto{\pgfqpoint{3pt}{3pt}}
    \pgfpathmoveto{\pgfqpoint{2.8pt}{-.2pt}}
    \pgfpathlineto{\pgfqpoint{3.2pt}{.2pt}}
    \pgfpathmoveto{\pgfqpoint{-.2pt}{2.8pt}}
    \pgfpathlineto{\pgfqpoint{.2pt}{3.2pt}}
    \pgfusepath{stroke}}
\tikzset{blob/.style={thick, pattern={south west lines}}}

% Text
\newcommand{\Mathematica}{\textit{Mathematica}}

% Maths
\newcommand{\identity}{1}
\newcommand{\identityMatrix}{\symbb{I}}
\newcommand{\symmetricGroup}[1][n]{\symfrak{S}_{#1}}
\DeclareMathOperator{\Mat}{Mat}
\RenewDocumentCommand{\matrices}{ o m m }{
    \IfNoValueTF{#1}{
        \Mat(#3, #2)
    }{
        \Mat(#3, #1 \times #2)
    }
}
\renewcommand{\field}{\symbb{k}}
\newcommand{\trans}{\top}
\newcommand{\hermit}{\dagger}
\newcommand{\action}{\mathbin{.}}
\ExplSyntaxOn
% Create LaTeX interface command
\NewDocumentCommand{\cycle}{ O{\,} m }{  % optional arg is separator, mandatory
    %arg is comma separated list
    (
    \willoughby_cycle:nn { #1 } { #2 }
    )
}

\clist_new:N \l_willougbhy_cycle_clist  % Create new clist variable
\cs_new_protected:Npn \willoughby_cycle:nn #1 #2 {  % create LaTeX3 function
    \clist_set:Nn \l_willougbhy_cycle_clist { #2 }  % set clist variable with
    %clist #2 passed by user
    \clist_use:Nn \l_willougbhy_cycle_clist { #1 }  % print list separated by #1
}
\ExplSyntaxOff
\DeclarePairedDelimiter{\tuple}{\langle}{\rangle}
\newcommand{\isomorphic}{\cong}
\newcommand{\projector}[1]{\symbfup{P}_{#1}}
\newcommand{\hermitianprojector}[1]{\symbfup{H}_{#1}}
\newcommand{\hooknumber}[1]{#1{\phantom{?}\mkern1mu\mathclap{\ooalign{\hfil ? \hfil \cr \hfil ! \hfil}}}}
\newcommand{\dual}[1]{{#1^{*}}}
\newcommand{\lorentzGroup}{\specialOrthogonal^+(1, 3)}
\newcommand{\minkowskiSpace}{\reals^{1,3}}
\DeclareMathOperator{\tr}{tr}
\renewcommand{\ve}[1]{e_{#1}}
\newcommand{\dualve}[1]{e^{#1}}
\newcommand{\minkowskiMetric}{\eta}
\newcommand{\e}{\symrm{e}}
\newcommand{\rep}[1]{\symbfup{#1}}
\newcommand{\threej}[4][0.3]{%
    \begin{tikzpicture}
        \draw[wire] (0, 0) circle [radius=#1];
        \draw[wire arrow reversed=0.3] (-#1, 0) -- (#1, 0) node [midway, above, font=\tiny, yshift=-0.05cm] {\(#2\)};
        \draw[wire, postaction={decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}}] (0.05, #1) -- ++ (0.01, 0);
        \draw[wire, postaction={decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}}] (0.05, -#1) -- ++ (0.01, 0);
        \node[font=\tiny] at (30:0.41) {\(#3\)};
        \node[font=\tiny] at (-30:0.4) {\(#4\)};
        \fill (#1, 0) circle [radius = 0.05];
        \fill (-#1, 0) circle [radius = 0.05];
    \end{tikzpicture}%
}
\newcommand{\threejnoarrow}[4][0.3]{%
    \begin{tikzpicture}
        \draw[wire] (0, 0) circle [radius=#1];
        \draw[wire] (-#1, 0) -- (#1, 0) node [midway, above, font=\tiny, yshift=-0.05cm] {\(#2\)};
        \node[font=\tiny] at (30:0.41) {\(#3\)};
        \node[font=\tiny] at (-30:0.4) {\(#4\)};
        \fill (#1, 0) circle [radius = 0.05];
        \fill (-#1, 0) circle [radius = 0.05];
    \end{tikzpicture}%
}
\newcommand{\sixjnoarrow}[7][0.5]{%
    \begin{tikzpicture}
        \draw[wire] (0, 0) circle [radius=#1];
        \draw[wire] (0, 0) -- (-30:#1) node [pos=0.6, above, font=\tiny, shift={(-0.03, -0.03)}] {\(#6\)};
        \draw[wire] (0, 0) -- (210:#1) node [pos=0.6, above, font=\tiny, shift={(0.03, -0.03)}] {\(#7\)};
        \draw[wire] (0, 0) -- (90:#1) node [midway, right, font=\tiny, xshift=-0.07cm] {\(#5\)};
        \fill (-30:#1) circle [radius=0.05];
        \fill (210:#1) circle [radius=0.05];
        \fill (90:#1) circle [radius=0.05];
        \node[font=\tiny] at (-90:#1-0.15) {\(#2\)};
        \node[font=\tiny] at (30:#1+0.2) {\(#4\)};
        \node[font=\tiny] at (150:#1+0.2) {\(#3\)};
    \end{tikzpicture}%
}
\DeclarePairedDelimiterX{\commutator}[2]{[}{]}{#1, #2}

\includeonly{}

\begin{document}
    \frontmatter
    \titlepage
    \maketitle
    \begin{abstract}
        The focus of this project was on using group theory and representation theory to simplify tensor expressions.
        We start by looking at tensors as objects transforming under representations of some group.
        We then look at how Young diagrams can be used to label the symmetries of a given tensor.
        These Young diagrams allow us to compute the irreducible representations of the symmetric group using Young projectors.
        These are expressed in a diagrammatic notation akin to Feynman diagrams, known as birdtracks, which can be used to represent both tensors and permutations.
        We then look at tensors in \(\specialUnitary(N)\) and in particular focus on computing \(\specialUnitary(N)\) scalars, motivated by the prevalence of \(\specialUnitary(N)\) in quantum field theory.
    \end{abstract}
    \tableofcontents
    % \listoffigures
    % \listoftables
    \chapter{Personal Statement}
    I spent the first few weeks familiarising myself with the basics of group theory and representation theory, building on my existing knowledge mostly through study of \cite{cvitanovic}.
    This text also introduces birdtracks, the main notation used for most of this work.
    I then moved on to studying the representation theory of the symmetric group, in particular looking at Young diagrams and Young projectors.
    Once I felt I had a good understanding of these I also started writing code, in \Mathematica{}.
    The rest of the project then followed a general pattern of studying a piece of mathematics and then writing code to implement the useful features of this mathematics.
    In this way in the first semester I studied Young diagrams, Young projectors, the Garnir relations, and representations of the symmetric group and begun implementing code for each of these, culminating in code which can compute the representation of a permutation in a given representation given by a Young diagram.
    I spent the first week implementing Young diagrams and Young tableaux so that they would display automatically.
    It then took approximately three weeks to implement the Garnir relations, allowing me to decompose arbitrary Young tableaux in terms of standard Young tableaux.
    From here it took about four more weeks to understand and implement the calculation of representations.
    The rest of the first semester I worked on implementing Young projectors.
    I also looked into Hermitian Young projectors, and implemented a method for computing these given Young projectors.
    
    Throughout the first semester I was also taking a course in group theory and studying quantum field theory.
    Both of these courses helped develop my understanding of the material in this project, and also demonstrated many applications of the concepts I was studying.
    At the same time I was attending a fortunately timed series of seminars by John Baez \cite{baez} which covered topics such as Young tableaux and Lie groups/algebras from a categorical approach.
    
    Over the Christmas break I focused on writing up what I had learned so far, and also read more about tensors in \(\specialUnitary(N)\).
    In second semester I studied \(3j\) and \(6j\) coefficients and the recoupling relations needed to simplify scalars.
    I spent about a week writing code which computed the hook formula, giving the dimension of a representation.
    I then begun writing code to use Young projectors to compute \(3j\) and \(6j\) coefficients.
    Throughout this time I was also taking a course on gauge theories, which had many applications of the mathematics I studied during this project, and a course on category theory, which generalises a lot of the ideas studied here and makes them rigorous.
    
    \mainmatter
    
    \chapter{Introduction}
    Tensors appear in many calculations in physics, from position vectors and the moment of inertia in classical mechanics, to four vectors and Lorentz transformations in special relativity, from state vectors and operators in quantum mechanics to the metric and Riemann tensors in general relativity.
    This wide spread use makes the ability to simplify and manipulate tensor expressions an essential skill for physicists.
    Much of the work in simplifying a tensor expression comes down to recognising certain symmetries of the system and exploiting these symmetries to simplify the expression.
    To do so we need a definition of a tensor, a definition of a symmetry, and a way to combine the two in order to simplify an expression.
    These definitions are the focus of the first part of this report, and the resulting methods of simplification are the focus of the second part.
    
    Throughout this project I have been working to simultaneously understand the mathematics behind tensors and to write code which implements the procedures which come out of this mathematics for simplification of tensor expressions.
    This report should lead the reader through the relevant mathematics and occasionally highlight relevant parts of the code\footnote{the code can be found on github: \url{https://github.com/WilloughbySeago/MPhysProjectCode}}.
    This code, mostly written in \Mathematica{}, has also been used to perform many of the calculations found in examples in this report.
    Before we jump straight into the maths we will give a brief overview of the key ideas introducing only a minimal amount of mathematics.
    
    \section{Overview}\label{sec:overview}
    A tensor is something which transforms like a tensor.
    This famously unhelpful definition can be made rigorous using group theory and representation theory.
    Group theory is broadly the study of symmetry, and can be used to simplify many problems down to basic algebraic manipulation.
    Representation theory allows us to further simplify this algebra to matrix manipulation, which can then be performed on a computer.
    
    One of the most powerful tools available for simplifying expressions with tensors is to exploit symmetries which these tensors posses.
    Often this comes in the form of the simple, yet surprisingly powerful, fact that the product of something symmetric with something antisymmetric must vanish.
    This can be demonstrated with a simple argument.
    Suppose \(S, A \colon \naturals \times \naturals \to \reals\) are a symmetric and antisymmetric function of natural numbers respectively.
    That is \(S(n, m) = S(m, n)\) and \(A(n, m) = -A(m, n)\).
    Then using these properties, and renaming the bound variables \(n\) and \(m\), we get the result
    \begin{alignat}{3}
        \sum_{\mathclap{n, m \in \naturals}} S(n, m)\mkern1muA(n, m) &= \sum_{\mathclap{n, m \in \naturals}} S(m, n)\mkern1muA(n, m)\\
        &= -\sum_{\mathclap{n, m \in \naturals}} S(m, n)\mkern1muA(m, n)\\
        &\overset{\mathclap{n \leftrightarrow m}}{=} \mkern10mu -\sum_{\mathclap{n, m \in \naturals}} S(n, m)\mkern1muA(n, m)
    \end{alignat}
    for all \(n, m \in \naturals\).
    Since only zero has the property of being equal to its negative we conclude
    \begin{equation}
        \sum_{\mathclap{n,m\in\naturals}} S(n, m)\mkern1mu A(n, m) = 0.
    \end{equation}
    This generalises to functions of arbitrarily many variables, whenever a function is symmetric in one pair of variables and another is antisymmetric in that same pair of variables their product vanishes identically.
    This also generalises to functions of continuous variables, replacing the sum with an integral.
    This will be the basis for many of the observations we make in this report.
    
    This result is probably familiar from expressions such as \(\delta_{ij}\varepsilon^{ijk} = 0\), where we employ the Einstein summation convention, as we shall do throughout this report.
    Recall that the Kronecker delta, \(\delta^{ij}\), is symmetric, \(\delta_{ij} = \delta_{ji}\), whereas the Levi--Civita symbol, \(\varepsilon^{ijk}\), is completely antisymmetric, that is it is antisymmetric in any pair of indices, so \(\varepsilon^{ijk} = \varepsilon^{kij} = \varepsilon^{jki} = -\varepsilon^{jik} = -\varepsilon^{ikj} = -\varepsilon^{kij}\).
    
    Another example which comes up in QED is the field strength tensor, \(F^{\mu\nu} \coloneqq \partial^\mu A^\nu - \partial^\nu A^\mu\), where\footnote{Note that we work in units where \(c = 1\).} \(A^\mu = (\varphi, \vv{A})\) is the four-potential, with \(\varphi\) and \(\vv{A}\) being the scalar and vector potentials, such that \(\vv{E} = -\grad\varphi - \partial_t\vv{A}\) and \(\vv{B} = \curl\vv{A}\) \cite[569]{griffiths}.
    As can be seen from the definition \(F^{\mu\nu}\) is antisymmetric, \(F^{\mu\nu} = -F^{\nu\mu}\).
    We can exploit this to simplify the product \(F^{\mu\nu}F_{\mu\nu}\), which occurs frequently in QED, being the term in the Lagrangian responsible for the propagation of photons \cite[294]{peskin}.
    Since \(F_{\mu\nu}\) is antisymmetric we are free to replace \(F^{\mu\nu}\) with any tensor whose antisymmetric part is \(F^{\mu\nu}\), since in this product the symmetric part will always vanish.
    Thus, we can replace \(F^{\mu\nu}\) with \(2\partial^\mu A^\nu\), and then we have
    \begin{equation}
        F^{\mu\nu}F_{\mu\nu} = 2(\partial^\mu A^\nu)F_{\mu\nu}.
    \end{equation}
    This halves the number of terms appearing when we expand \(F_{\mu\nu}\), simplifying many calculations in QED.
    
    The question then is how do we deal with objects with more complex symmetries?
    Tensors which aren't just totally symmetric or totally antisymmetric, but symmetric in some indices, antisymmetric in others, and possibly with some indices which don't take part in any such symmetry.
    An example of such a tensor is the Riemann tensor appearing in general relativity, characterising the curvature of spacetime.
    The Riemann tensor, \(R_{\mu\nu\rho\sigma}\), has the following symmetries \cite[141]{weinberg}:
    \begin{itemize}
        \item antisymmetric in the first two indices: \(R_{\mu\nu\rho\sigma} = -R_{\nu\mu\rho\sigma}\)
        \item antisymmetric in the second two indices: \(R_{\mu\nu\rho\sigma} = -R_{\mu\nu\sigma\rho}\)
        \item symmetric upon exchange of the first pair of indices with the second pair of indices: \(R_{\mu\nu\rho\sigma} = R_{\rho\sigma\mu\nu}\).
    \end{itemize}
    
    This motivates much of the work in the following report.
    First, we need a general definition of a tensor to understand the sort of objects with which we are working.
    This leads to group theory and representation theory.
    Then we should find a way to classify these symmetries.
    This will lead to the idea of the symmetric group and Young diagrams and Young tableaux.
    Once we have these we will look for a way to produce tensors with these symmetries.
    This leads to the idea of Young projectors.
    Finally we look at how these ideas can be applied to simplify tensor expressions.
    
    \section{Preliminary Matters}
    The Einstein summation convention will be in place throughout this report, whenever an index is repeated twice it is to be summed over, unless explicitly told otherwise.
    Generally repeated indices must be one up and one down, although there are certain cases where this requirement can be relaxed.
    
    Greek letters are used for Lorentz indices, for example, \(\mu\) and \(\nu\).
    These run from 0 to 3, with 0 being the time coordinate and 1, 2, and 3 the three spatial coordinates.
    In this context Latin letters, such as \(i\) and \(j\), are used to denote explicitly the spatial components.
    
    In more general settings Latin letters are used as indices.
    The values these take on run from 1 to the dimension of the space, which is usually evident from context.
    
    In particular for a Lie group indices are taken from the start of the alphabet, using \(a\) and \(b\), and so on.
    
    We use the metric signature \(({+}{-}{-}{-})\) throughout, so the Minkowski metric and its inverse both have the matrix form \(\minkowskiMetric = \diag(1, -1, -1, -1)\).
    
    Throughout this report we shall make reference to the algebraic objects known as rings and fields in an attempt to make things as general as possible.
    If the reader is not familiar with these concepts then they may simply replace rings with the integers, \(\integers\), and fields with either the real numbers, \(\reals\), or complex numbers, \(\complex\).
    
    It is assumed that the reader is familiar with basic linear algebra, such as vectors and matrices.
    A few necessary concepts which appear less often in physics are recapped in \cref{sec:linear algebra}.
    
    \chapter{Tensors}
    We start by looking at the definition of a tensor.
    This definition can be neatly summarised as \enquote{a tensor is something which transforms like a tensor} \cite[52]{zee}.
    However, in doing so we deliberately avoid defining how a tensor transforms.
    Often it is enough to simply define how a specific type of tensor transforms.
    For example, in classical mechanics most of the tensors we are interested in are Cartesian tensors, these are tensors which transform under a rotation using a rotation matrix, although even here we aren't being explicit about how this rotation matrix is used.
    
    To define the transformation of a tensor in the most general way possible we need to be able to reason about general transformations, this leads to the notion of a group, a collection of symmetries with a way of combining two symmetries.
    We then need to define how an abstract group corresponds to a transformation of a vector space.
    This leads to the idea of a representation.
    We then use representations to define how a tensor transforms, and hence, what a tensor is.
    
    \section{Groups}
    Groups capture and abstract the idea of a symmetry.
    Intuitively a symmetry is something we can do to a system which leaves the system unchanged, or \defineindex{invariant}, under that symmetry.
    We can abstract the notion of a symmetry through four requirements.
    Given some collection of symmetries there must be a way to combine them, some way to do nothing to the system, some way to undo any of the symmetries, and the final requirement is more technical, but can be neatly summarised as \enquote{it doesn't matter how we use brackets when writing down these symmetry compositions}.
    This leads to the following definition.
    
    \begin{dfn}{Group}{}
        A \defineindex{group}, \((G, \cdot)\), is a set, \(G\), and a binary operation, \(\cdot \colon G \times G \to G\) such that the following axioms are satisfied \cite{riley-hobson-bence}:
        \begin{description}
            \item[Identity]\index{identity} there exists some distinguished element, \(\identity \in G\), such that for all \(x \in G\) we have \(\identity \cdot x = x \cdot \identity = x\);
            \item[Inverse]\index{inverse} for all \(x \in G\) there exists some \(x^{-1} \in G\) such that \(x \cdot x^{-1} = x^{-1} \cdot x = \identity\);
            \item[Associativity]\index{associativity} for all \(x, y, z \in G\) we have \((x \cdot y) \cdot z = x \cdot (y \cdot z)\).
        \end{description}
    \end{dfn}
    
    We follow the common abuse of terminology and refer to \(G\) alone as the group with the operation left implicit.
    We will also write most group operations as juxtaposition, writing \(xy\) for \(x \cdot y\).
    
    The prototype for a group is the \defineindex{symmetric group} on \(n\) objects, \(\symmetricGroup\) \cite{james-rep-symmetric-group}.
    This is defined as the set
    \begin{equation}
        \symmetricGroup \coloneqq \{ \sigma \colon \{1, \dotsc, n\} \to \{1, \dotsc, n\} \mid \sigma \text{ is a bijection} \}
    \end{equation}
    with function composition as the group operation.
    We will use cycle notation for elements of \(\symmetricGroup\), where a cycle sends each element to the next in the list and the last element in the list to the first.
    For example, \(\cycle{1,3,4}\) sends \(1\) to \(3\), \(3\) to \(4\), and \(4\) to \(1\).
    In this notation the identity is the empty cycle, \(\cycle{}\).
    
    Given two groups, \(G\) and \(H\), we can form a new group, called the \defineindex{direct product} \(G \otimes W\), whose elements are pairs \((g, h) \in G \times H\), that is \(g \in G\) and \(h \in H\), with the group operation \((g, h)(g', h') = (gg', hh')\) for \(g, g' \in G\) and \(h, h' \in H\).
    
    Another important family of groups are various collections of matrices with matrix multiplication as the group operation.
    In this case the group identity is the identity matrix of  the appropriate dimension, \(\identityMatrix\).
    Let \(\matrices{n}{R}\) denote the set of \(n \times n\) matrices with entries in a ring \(R\).
    The following are all groups under matrix multiplication \cite{allanach}:
    \begin{itemize}
        \item \defineindex{general linear group} \(\generalLinear(n, \field) \coloneqq \{M \in \matrices{n}{R} \mid M \text{ is invertible} \}\);
        \item \defineindex{special linear group} \(\specialLinear(n, \field) \coloneqq \{M \in \generalLinear(n, R) \mid \det M = 1\}\);
        \item \defineindex{orthogonal group} \(\orthogonal(n) \coloneqq \{O \in \matrices{n}{\reals} \mid O^\trans O = \identityMatrix \}\);
        \item \defineindex{special orthogonal group} \(\specialOrthogonal(n) \coloneqq \{O \in \orthogonal(n) \mid \det O = 1\}\);
        \item \defineindex{unitary group} \(\unitary(n) \coloneqq \{U \in \matrices{n}{\complex} \mid U^\hermit U = \identityMatrix \}\);
        \item \defineindex{special unitary group} \(\specialUnitary(n) \coloneqq \{U \in \unitary(n) \mid \det U = 1\}\).
        \item (proper orthochronous) \defineindex{Lorentz group} \(\specialOrthogonal^+(1, 3) \coloneqq \{\Lambda \in \Mat(\reals, 4) \mid \Lambda^{\trans}\minkowskiMetric \Lambda = \minkowskiMetric \land \det \Lambda = 1 \land \tensor{\Lambda}{^0_0} \ge 1\}\).
    \end{itemize}
    Most of the transformations we are interested in will form a Lie group like one of these examples, for example, \(\specialOrthogonal(n)\) corresponds to rotations in \(n\) dimensions and \(\specialOrthogonal^+(1, 3)\) corresponds to Lorentz transformations.
    These matrix groups are actually examples of a Lie group.
    
    \begin{dfn}{Lie Group}{}
        A \defineindex{Lie group}, \(G\), is a group which is also a manifold in a compatible way \cite{san-martin-lie-groups}.
        In particular, the product map, \(\cdot \colon G \times G \to G\), is analytic.
    \end{dfn}
    
    Given a Lie group, \(G\), it is possible to parametrise the group elements as \(g = \exp\{i\vartheta_aT^a\}\) for some objects \(T^a\), which we call the \define{generators}\index{generator} of \(G\), and scalars \(\vartheta_a \in \field\) and \(a = 1, \dotsc, \dim G\).
    The generators \(T^a\) span a vector space, \(\lie{g}\), over a field, \(\field\), called the \defineindex{Lie algebra} of \(G\).
    An \defineindex{algebra} is a vector space, \(V\), equipped with a product of vectors, \(V \times V \to V\), which is compatible with vector addition and multiplication, see \cref{sec:algebras} for details.
    The product in the case of a Lie algebra is the \defineindex{Lie bracket}, \(\commutator{-}{-} \colon \lie{g} \times \lie{g} \to \lie{g}\).
    This has the following properties:
    \begin{itemize}
        \item linearity in both arguments: \(\commutator{ax + by}{z} = a\commutator{x}{z} + b\commutator{y}{z}\) and \(\commutator{x}{ay + bz} = a\commutator{x}{y} + b\commutator{x}{z}\) for all \(a, b \in \field\) and \(x, y, z \in \lie{g}\),
        \item antisymmetry: \(\commutator{x}{x} = 0\) for all \(x \in \lie{g}\),
        \item the \defineindex{Jacobi identity}: \(\commutator{x}{\commutator{y}{z}} + \commutator{y}{\commutator{z}{x}} + \commutator{z}{\commutator{x}{y}} = 0\) for all \(x, y, z \in \lie{g}\).
    \end{itemize}
    The first two properties combined imply anticommutativity\footnote{So long as \(\field\) is not characteristic 2. Both \(\reals\) and \(\complex\) have characteristic 0.}: \(\commutator{x}{y} = -\commutator{y}{x}\) for all \(x, y \in \lie{g}\).
    For the examples of matrix Lie groups above the Lie bracket is simply the commutator \(\commutator{x}{y} = xy - yx\), and the Lie algebra is some collection of matrices under matrix multiplication.
    For example, \(\specialUnitaryLie(N)\) consists of Hermitian\footnote{Hermitian because we include a factor of \(i\) in \(\exp\{i\vartheta_a T^a\}\), mathematicians typically don't do this and so take \(T^a\) to be traceless anti-Hermitian matrices.} traceless matrices over \(\complex\).
    
    Most of the time when considering a group we think of the symmetries it represents being applied to some object.
    Indeed, even group multiplication can be viewed as the symmetries of the group being applied to itself.
    Thinking in this way leads to the following definition in which each group element represents a symmetry that can be applied to some object.
    
    \begin{dfn}{Group Action}{}
        Let \(G\) be a group and \(X\) a set.
        A (left) \defineindex{group action} of \(G\) on \(X\) is a function \(\varphi \colon G \times X \to X\) such that \cite[713]{hassani}
        \begin{description}
            \item[Identity] for all \(x \in X\) we have \(\varphi(\identity, x) = x\),
            \item[Compatibility] for all \(g, h \in G\) and \(x \in X\) we have \(\varphi(g, \varphi(h, x)) = \varphi(gh, x)\) where \(gh\) is the product of \(g\) and \(h\) in \(G\).
        \end{description}
    \end{dfn}
    
    We usually write \(\varphi(g, x) = g \action x\), or even \(\varphi(g, x) = gx\).
    In this case the identity and compatibility laws take the form \(\identity \action x = x\) and \(g \action (h \action x) = (gh) \action x\), with \(gh\) being the product of \(g\) and \(h\) computed as elements of \(G\).
    
    The symmetric group, \(\symmetricGroup\), acts on \(n\)-tuples, \(\tuple{a_1, \dotsc, a_n}\), by permuting the elements.
    For example, \(\cycle{1,3,4} \in \symmetricGroup[5]\) acts on \(\tuple{a_1, a_2, a_3, a_4, a_5}\) by
    \begin{equation}
        \cycle{1,3,4} \action \tuple{a_1, a_2, a_3, a_4, a_5} = \tuple{a_4, a_2, a_1, a_3, a_5}.
    \end{equation}
    Note that this action is done by permuting the symbols \(a_i\), rather than by permuting the values of \(i\), which would instead give \(\tuple{a_3, a_2, a_4, a_1, a_5}\).
    
    Matrix groups, such as \(\generalLinear(n, \field)\) for a field \(\field\), have a natural action on the \(n\)-dimensional vector space \(\field^n\) by interpreting elements of \(\field^n\) as column matrices and then acting on them through matrix multiplication.
    The action of matrices on vector spaces in this form turns out to be a very useful way of thinking about a group, since matrix multiplication is simple and easy to perform on a computer.
    This insight leads to the idea of a representation, the subject of the next section.
    
    \begin{dfn}{Morphisms}{}
        Let \(G\) and \(H\) be groups.
        A \defineindex{group homomorphism} is a map \(\varphi \colon G \to H\) such that \(\varphi(gg') = \varphi(g)\varphi(g')\) for all \(g, g' \in G\) \cite[705]{hassani}.
        If \(\varphi\) is invertible then we call it an \defineindex{isomorphism}.
        If there is an isomorphism between \(G\) and \(H\) we say that \(G\) and \(H\) are \defineindex{isomorphic}, and denote this \(G \isomorphic H\).
    \end{dfn}
    
    Notice that if \(\identity_G\) and \(\identity_H\) are the identity elements of \(G\) and \(H\) respectively then we have \(\varphi(\identity_G) = \identity_H\) as well as \(\varphi(g^{-1}) = \varphi(g)^{-1}\) for all \(g \in G\).
    
    As mentioned before every group has a natural action on itself, that is a function \(G \times G \to G\), given by \(g \action h = gh\).
    In this way every group element, \(g\), defines a bijection \(\varphi_g \colon G \to G\) defined by \(\varphi_g(h) = gh\).
    The collection of these bijections, along with function composition, is isomorphic to the group itself, and is a subgroup of some symmetric group.
    This is Cayley's theorem, and highlights the importance of the symmetric group.
    % TODO: Find a citation
    
    There are often times when it makes sense to combine the structure of a group with the structure of a vector space, the ability to add elements and scale by some scalar.
    This leads to the following definition.
    
    \begin{dfn}{Group Algebra}{}\index{group algebra}
        Let \(G\) be a group and \(R\) a ring.
        The group ring, \(R[G]\), is the set of formal sums
        \begin{equation}
            \sum_{g \in G} r_g g
        \end{equation}
        where \(r_g \in R\) is zero for all but a finite number of elements \(g\).
        This set of formal sums is a ring with addition defined as
        \begin{equation}
            \sum_{g \in G} r_g g + \sum_{g \in G} s_g g \coloneqq \sum_{g\in G}(r_g + s_g) g
        \end{equation}
        and multiplication defined as
        \begin{equation}
            \left( \sum_{g \in G} r_g g \right) \left( \sum_{h \in G} s_h h \right) \coloneqq \sum_{g, h \in G}^{g} r_g s_h gh
        \end{equation}
        with the product \(r_gs_h\) computed in \(R\) and the product \(gh\) computed in \(G\).
        If \(R\) is a field then \(R[G]\) is an associative algebra (a vector space with an associative product), called the \defineindex{group algebra} \cite[740]{hassani}.
    \end{dfn}
    
    Note that an algebra is just a vector space with an extra operation \(V \times V \to V\) giving the product of two vectors in a way which is compatible with vector addition and scalar multiplication.
        
    The most common case of a group algebra is the group algebra \(\complex[G]\) for some arbitrary group, \(G\).
    Elements of this take the form \(z_i g_i\) for some \(z_i \in \complex\) and \(g_i \in G\), using the Einstein summation convention.
    
    \section{Representations}% TODO: define fundamebtal and adjoint representation
    Let \(V\) be a vector space over the field \(\field\).
    Denote by \(\generalLinear(V)\) the space of all invertible linear transformations on \(V\), that is
    \begin{equation}
        \generalLinear(V) \coloneqq \{T \colon V \to V \mid T \text{ is linear and invertible}\}.
    \end{equation}
    For finite dimensional vector spaces if we fix some basis for \(V\) then we can identify linear transformations with matrices and we find that \(\generalLinear(V) \isomorphic \generalLinear(\dim V, \field)\).
    
    The general linear group, \(\generalLinear(V)\), has a natural group action on \(V\), namely, \(T \action v = T(v)\) for a linear transformation \(T \in \generalLinear(V)\) and a vector \(v \in V\).
    This can be extended to an arbitrary group, \(G\), by factoring this action through a group homomorphism.
    That is we can map \(G\) into \(\generalLinear(V)\) with a group homomorphism, \(\rho \colon G \to \generalLinear(V)\), turning group elements in \(g\) into linear transformations on \(V\), then act on \(V\) with these linear transformations.
    This defines a group action \(\action \colon G \times V \to V\), given by \(g \action v = \rho(g)(v)\).
    The notation \(\rho(g)(v)\) denotes evaluating \(\rho\) at \(g \in G\), returning a linear transformation \(\rho(g) \in \generalLinear(V)\), which we then evaluate at \(v\).
    The result is what we call a representation, an alternative definition is given below.
    
    \begin{dfn}{Representation}{}
        Let \(G\) be a group.
        A \defineindex{group representation}, \((\rho, V)\), is a pair consisting of a vector space, \(V\), called the representation space, and a homomorphism \(\rho \colon G \to \generalLinear(V)\) \cite[726]{hassani}.
    \end{dfn}
    
    It is common to refer to both \(\rho\), \(V\), alone, as well as the pair \((\rho, V)\) as the representation.
    While we can take representations over arbitrary fields we will restrict ourselves to representations over \(\complex\), since these have the most applications in physics.
    
    The simplest example of a representation is the \defineindex{trivial representation}, \((\rho_{\text{trivial}}, V)\), which acts trivially on \(V\), that is \(\rho_{\text{trivial}}(g) = \identityMatrix\), or equivalently, \(g \action v = v\) for all \(g \in G\).
    
    \begin{exm}{Permutation Representation}{}
        Consider the symmetric group on three elements, \(\symmetricGroup[3]\).
        This has a representation on \(\reals^3\) given by identifying
        \begin{equation*}
            \rho\cycle{1,2} = 
            \begin{pmatrix}
                0 & 1 & 0\\
                1 & 0 & 0\\
                0 & 0 & 1
            \end{pmatrix}
            ,\ \rho\cycle{1,3} = 
            \begin{pmatrix}
                0 & 0 & 1\\
                0 & 1 & 0\\
                1 & 0 & 0
            \end{pmatrix}
            , \ \text{and} \  \rho\cycle{2,3} = 
            \begin{pmatrix}
                1 & 0 & 0\\
                0 & 0 & 1\\
                0 & 1 & 0
            \end{pmatrix}
            .
        \end{equation*}
        This representation acts by permuting the basis vectors \(\ve{1} = (1, 0, 0)^\trans\), \(\ve{2} = (0, 1, 0)^\trans\), and \(\ve{3} = (0, 0, 1)^\trans\), for example \(\rho\cycle{1,2} \mkern1mu \ve{1} = \ve{2}\), so we call this the \defineindex{permutation representation}.
        The representation of any other group element can be found by writing the element as a product of \define{transpositions}\index{transposition} (two element cycles).
        For example, \(\cycle{1,2,3} = \cycle{1,2}\cycle{2,3}\) and so
        \begin{multline}
            \rho\cycle{1,2,3} = \rho(\cycle{1,2} \cycle{2,3}) = \rho\cycle{1,2} \, \rho\cycle{2,3}\\
            = 
            \begin{pmatrix}
                0 & 1 & 0\\
                1 & 0 & 0\\
                0 & 0 & 1
            \end{pmatrix}
            \begin{pmatrix}
                1 & 0 & 0\\
                0 & 0 & 1\\
                0 & 1 & 0
            \end{pmatrix}
            = 
            \begin{pmatrix}
                0 & 0 & 1\\
                1 & 0 & 0\\
                0 & 1 & 0
            \end{pmatrix}
            .
        \end{multline}
    \end{exm}
    
    \begin{exm}{Fundamental and Adjoint Representations}{}
        Given a Lie group, \(G\), there are two representations we are generally interested in.
        The first is the \defineindex{fundamental}\index{fundamental representation}, or defining, representation.
        This is the representation used to define the group.
        For example, given a matrix Lie group of \(N \times N\) matrices over \(\field\) the fundamental representation is \(\field^N\) and the group acts on this space by matrix multiplication.
        This is an \(N\) dimensional representation.
        
        The other representation is the \defineindex{adjoint representation}, in which the Lie group acts on the Lie algebra.
        We will restrict ourselves to the case where the Lie group is a matrix group.
        Then this action is given by conjugation, \(g \action T^a = gT^a g^{-1}\), where the product on the right is matrix multiplication.
        This representation has the same dimension as \(G\) and \(\lie{g}\).
        For example, in the case of \(\specialUnitary(N)\) there are \(N^2 - 1\) \(N \times N\) traceless Hermitian matrices, so the adjoint representation has dimension \(N^2 - 1\).
        
        These representations are important in quantum field theory, since the representation a particle transforms under tells us a lot about the properties of that particle.
        In particular, for \(\specialUnitary(3)\) the fundamental representation is 3 dimensional, corresponding to the 3 colours, and the adjoint representation is 8 dimensional, corresponding to the 8 gluons.
    \end{exm}
    
    There are an infinite number of representations of any group, however, they are not all equally interesting.
    This is evident since given some representation, \((\rho, V)\), we can form a new representation \((\rho', W)\), where \(V\) is a subspace of \(W\), by defining \(\rho' = \rho \oplus \identityMatrix_{V^\perp}\) where \(V^{\perp}\) is the space such that \(W = V \oplus V^{\perp}\), so \(\rho'(g)\) acts as \(\rho(g)\) on the subspace \(V\) and acts trivially on the orthogonal subspace \(V^{\perp}\).
    Clearly this representation doesn't really give us any new information.
    More generally, given two representations, \((\rho_1, V_1)\) and \((\rho_2, V_2)\), we can form a representation \((\rho_1 \oplus \rho_2, V_1 \oplus V_2)\), again, we don't get any new information out of this new representation.
    For this reason we define irreducible representations, which are exactly the representations which aren't of this form.
    
    \begin{dfn}{Irreducible Representation}{}
        Let \(G\) be a group and \((\rho, V)\) a representation of \(G\).
        We say that \((\rho, V)\) is an \defineindex{irreducible representation}, or irrep, if \(V\) has no \(G\)-invariant subspaces \cite{hamermesh}.
        That is, there is no \(W \subset V\) such that \(g \action w \in W\) for all \(w \in W\).
    \end{dfn}

    \begin{dfn}{Decomposable Representation}{}
        Let \(G\) be a group and \((\rho, V)\) a representation of \(G\).
        We say that \((\rho, V)\) is a \defineindex{decomposable representation} if \(\{\rho(g)\}\) can be simultaneously block diagonalised \cite{hamermesh}.
        In other words, there exist representations \((\rho_i, V_i)\) such that \(\rho = \bigoplus_i \rho_i\) and \(V = \bigoplus_i V_i\).
    \end{dfn}
    
    For a finite group, \(G\), and a representation space over \(\reals\) or \(\complex\) all indecomposable representations are irreducible \cite{hamermesh}.
    This also the case if \(G\) is compact.
    We will assume that all indecomposable are irreducible and vice versa.
    
    Representations give us the final piece of machinery required to make \enquote{a tensor is something which transforms like a tensor} precise.
    A tensor is something which transforms under some representation of 
    \begin{dfn}{Tensor}{def:tensor}
        Let \(G\) be a group and \(V\) a vector space over a field \(\field\).
        Denote by \(\dual{V}\) the dual space to \(V\), that is the space of all linear maps \(V \to \field\).
        Fix some representation \(\rho \colon G \to \generalLinear(V)\).
        A \defineindex{tensor}, \(T \in V^{\otimes p} \otimes \dual{V}^{\otimes q}\), is an object with components \(\tensor{T}{^{a_1\dotso a_q}_{b_1 \dotso b_p}}\), which transform under the action of \(g \in G\) such that \(T' = g \action T = \rho(g)T\) has components
        \begin{equation*}
            \tensor{{T'}}{^{a_1\dotso a_q}_{b_1 \dotso b_p}} = \tensor{\rho(g)}{^{a_1}_{c_1}} \dotsm \tensor{\rho(g)}{^{a_q}_{c_q}} \tensor{\rho(g)}{_{b_1}^{d_q}} \dotsm \tensor{\rho(g)}{_{b_p}^{d_p}} \tensor{T}{^{c_1\dotso c_q}_{d_1 \dotso d_p}}
        \end{equation*}
        where we employ the Einstein summation convention and sum over repeated indices from \(1\) to \(\dim V\) \cite[18]{cvitanovic}.
    \end{dfn}
    
    We will follow the common physics abuse of terminology and refer to the components \(\tensor{T}{^{a_1\dotso a_q}_{b_1\dotso b_p}}\) as being the tensor see \cref{sec:technicalities tensor defs}.
    
    Note that what we have defined above may be more specifically called a \((p, q)\)-tensor.
    A \((p, 0)\)-tensor is also commonly referred to as a rank \(p\) contravariant tensor, or simply a rank \(p\) tensor, and a \((0, q)\)-tensor may be referred to as a rank \(q\) covariant tensor.
    
    If a tensor transforms under no copies of \(G\), that is it carries no indices, then we say it is a \defineindex{scalar}.
    If a tensor transforms under a single copy of \(G\), that is it carries a single index, then we say it is a \defineindex{vector}.
    Note that these definitions are technically incompatible with the mathematicians definitions, where scalars are elements of \(\field\) and vectors are elements of a vector space, including spaces like \(\field\) and \(V \otimes V\), whereas physicists would call \(T \in V \otimes V\) a rank 2 tensor and not a vector.
    
    \begin{exm}{}{}
        In classical mechanics we consider Cartesian tensors, which transform under the rotation group \(\specialOrthogonal(3)\).
        For example, if \(R \in \specialOrthogonal(3)\) is a rotation matrix then \(\vv{x} \in \reals^3\) is a vector if it has components transforming according to
        \begin{equation}
            x_i = R_{ij}x_j.
        \end{equation}
        The moment of inertia tensor, \(I\), has components \(I_{ij}\) and transforms as
        \begin{equation}
            I'_{ij} = R_{ik}R_{jl}I_{kl},
        \end{equation}
        so it is a rank 2 tensor.
        
        In relativity we consider Lorentz tensors, which transform under the Lorentz group \(\lorentzGroup\).
        For example, if \(\Lambda \in \lorentzGroup\) is a Lorentz transformation then \(x \in \minkowskiSpace\) is a vector if it has components transforming according to
        \begin{equation}
            x^\mu = \tensor{\Lambda}{^\mu_\nu}x^\nu.
        \end{equation}
        The energy-momentum tensor, \(T\), has components \(T^{\mu\nu}\) which transform as
        \begin{equation}
            T'^{\mu\nu} = \tensor{\Lambda}{^\mu_\rho}\tensor{\Lambda}{^\nu_\sigma} T^{\rho\sigma},
        \end{equation}
        so it is a rank 2 contravariant tensor.
    \end{exm}
    
    Given two tensors, \(R \in V^{\otimes q} \otimes \dual{V}^{\otimes p}\) and \(T \in V^{\otimes r} \otimes \dual{V}^{\otimes s}\), we can form a new tensor \(R \otimes T \in V^{\otimes(q + r)} \otimes \dual{V}^{\otimes(p + s)}\), with components given by
    \begin{equation}
        \tensor{(R \otimes T)}{^{a_1\dotso a_q b_1 \dotso b_r}_{c_1 \dotso c_p d_1 \dotso d_s}} = \tensor{R}{^{a_1\dotso a_q}_{c_1 \dotso c_p}} \tensor{T}{^{b_1 \dotso b_r}_{d_1 \dotso d_s}}.
    \end{equation}
    This operation is often used implicitly, such as writing \(k^\mu k^\nu\), and neglecting to note that this object actually lives in a different space to \(k^\mu\), namely it lives in \(V \otimes V\).
    
    % TODO: Maybe talk about raising and lowering indices? Using Killing form?
    
    \section{Birdtracks}
    \subsection{Birdtracks for Tensors}
    Equations involving multiple tensors, particularly with contractions between the tensors, can quickly become a mess of indices, and keeping track of which indices are free and which are summed can be a demanding task.
    Anyone who's worked with tensors extensively will have at some point in their calculations run out of appropriate letters to use as indices, and accidentally reusing a letter can make an entire expression completely meaningless.
    For this reason we now introduce a notation known as \defineindex{birdtracks} for expressing the components of tensors.
    
    Birdtracks are inspired by Feynman diagrams, and indeed sometimes arise explicitly as Feynman diagrams, and indeed many Feynman diagrams can be directly interpreted as birdtracks.
    This notation was first developed by Roger Penrose % TODO: citation
    who originally designed the notation for use in general relativity.
    The general idea is to represent a tensor as a vertex in a graph, with the edges of the graph, which we call wires, being the indices of the tensor.
    Two vertices are joined by an edge if that index is contracted over.
    We distinguish contravariant and covariant indices where required with arrows on the line, pointing away from the vertex for a contravariant index and towards it for a covariant index.
    Allowing only one arrow on each line ensures that we can only contract a contravariant index with a covariant index.
    
    For example, suppose we have a tensor with components \(\tensor{T}{^{abc}_{de}}\), which we wish to represent in this notation.
    We write this as
    \begin{equation}
        \tensor{T}{^{abc}_{de}} = 
        \tikzsetnextfilename{birdtracks-example-tensor}
        \begin{tikzpicture}[baseline=(T.base)]
            \node[draw, minimum width=1cm, minimum height=1.5cm] (T) {\(T\)};
            \draw[wire arrow reversed=0.425] ($(T.west) + (0, 0.6)$) -- ++ (-1, 0) node [left, font=\scriptsize] {\(a\)};
            \draw[wire arrow reversed=0.425] ($(T.west) + (0, 0.3)$) -- ++ (-1, 0) node [left, font=\scriptsize] {\(b\)};
            \draw[wire arrow reversed=0.425] (T.west) -- ++ (-1, 0) node [left, font=\scriptsize] {\(c\)};
            \draw[wire arrow=0.575] ($(T.west) + (0, -0.3)$) -- ++ (-1, 0) node [left, font=\scriptsize] {\(d\)};
            \draw[wire arrow=0.575] ($(T.west) + (0, -0.6)$) -- ++ (-1, 0) node [left, font=\scriptsize] {\(e\)};
        \end{tikzpicture}
        .
    \end{equation}
    We include the index labels only for comparison with the notation \(\tensor{T}{^{abc}_{de}}\), in general they can be dropped.
    In doing so it is important to always read the indices going anticlockwise around the tensor to get the order correct.
    Which index we start with often doesn't matter, as long as we are consistent, but when it does we may mark the starting index, or arrange the indices in such a way that it is clear where to start, here we do so by having \(a\) at the top.
    
    It is not important at what position a wire enters a node, nor is it important where the wire goes if the corresponding index is not contracted.
    This leaves us free to bend wires, and move them around as needed.
    It is only the connectivity between different tensors which we care about.
    
    The Kronecker delta is a common enough tensor that we give it its own special notation, we draw it as a wire with no node:
    \begin{equation}
        \tensor{\delta}{^a_b} = 
        \tikzsetnextfilename{birdtracks-kronecker-delta}
        \begin{tikzpicture}[baseline=(b.base)]
            \draw[wire arrow=0.575] (0, 0) node [right, font=\scriptsize] {\(a\)} -- (-1, 0) node [left, font=\scriptsize] (b) {\(b\)};
        \end{tikzpicture}
        .
    \end{equation}
    In the language of Feynman diagrams we may refer to this as a propagator.
    Indeed, many propagators, such as those of a particle with colour charge, carry a factor of \(\tensor{\delta}{^a_b}\), acting as the identity on colour space, so the colour of the particle doesn't change as it propagates.
    
    To contract tensors we join up the contracted indices.
    For example, we can write \(\tensor{T}{^{abc}_{de}}\tensor{R}{^{d}_{afc}}\) as
    \begin{equation}
        \tensor{T}{^{abc}_{de}} \tensor{R}{^{d}_{afc}} = 
        \tikzsetnextfilename{birdtracks-contraction}
        \begin{tikzpicture}[baseline=(T.base)]
            \node[draw, minimum width=1cm, minimum height=1.5cm] (T) {\(T\)};
            \draw[wire arrow=0.575] ($(T.east) + (0, 0.6)$) -- ++ (1, 0) node [right, font=\scriptsize, xshift=-0.1cm] {\(e\)};
            \draw[wire arrow=0.575] ($(T.east) + (0, 0.3)$) -- ++ (1, 0) coordinate (T2);
            \draw[wire arrow reversed=0.425] (T.east) -- ++ (1, 0) coordinate (T3);
            \draw[wire arrow reversed=0.425] ($(T.east) + (0, -0.3)$) -- ++ (1, 0) node [right, font=\scriptsize, xshift=-0.1cm] {\(b\)};
            \draw[wire arrow reversed=0.425] ($(T.east) + (0, -0.6)$) -- ++ (1, 0) coordinate (T5);
            \node[draw, minimum width=1cm, minimum height=1.5cm] (R) at (4, 0) {\(R\)};
            \draw[wire arrow=0.575] ($(R.west) + (0, 0.6)$) -- ++ (-1, 0) coordinate (R1);
            \draw[wire arrow=0.575] ($(R.west) + (0, 0.2)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.13cm] {\(f\)};
            \draw[wire arrow=0.575] ($(R.west) + (0, -0.2)$) -- ++ (-1, 0) coordinate (R3);
            \draw[wire arrow reversed=0.425] ($(R.west) + (0, -0.6)$) -- ++ (-1, 0) coordinate (R4);
            \draw[over wire, rounded corners] ($(T2) + (-0.1, 0)$) -- ++ (0.4, 0) -- ++ (0.4, -0.9) -- ($(R4) + (0.1, 0)$) node [below, font=\scriptsize, shift={(-0.2, 0.08)}] {\(d\)};
            \draw[over wire, rounded corners] ($(T3) + (-0.1, 0)$) -- ++ (0.4, 0) -- ++ (0.4, 0.6) -- ($(R1) + (0.1, 0)$) node [above, font=\scriptsize, shift={(-0.2, -0.08)}] {\(c\)};
            \draw[over wire, rounded corners] ($(T5) + (-0.1, 0)$) -- ++ (0.4, 0) -- ++ (0.4, 0.4) -- ($(R3) + (0.1, 0)$) node [above, font=\scriptsize, shift={(-0.2, -0.08)}] {\(a\)};
        \end{tikzpicture}
        .
    \end{equation}
    Again, the indices are labelled for comparison to the index notation.
    
    It is possible to contract indices on the same tensor, this is drawn as a loop.
    For example, given a rank 2 tensor \(M\) its trace is
    \begin{equation}
        \tr(M) = \tensor{M}{^a_a} = 
        \tikzsetnextfilename{birdtracks-trace}
        \begin{tikzpicture}[baseline=(M.base)]
            \node[draw] (M) {\(M\)};
            \node at (0, 0.45) {};
            \draw[wire arrow=0.54] (M.west) arc (270:90:0.2) coordinate (here) -- (M.east |- here) arc (90:-90:0.2);
        \end{tikzpicture}
        .
    \end{equation}
    A particularly common example of this is the trace of the Kronecker delta, \(\tensor{\delta}{^a_a} = n\), where \(n\) is the dimension of the vector space \(V\), recalling that \(\delta \in V \otimes \dual{V}\).
    This is then drawn as
    \begin{equation}
        \tensor{\delta}{^a_a} = 
        \tikzsetnextfilename{birdtracks-kronecker-delta-trace}
        \begin{tikzpicture}[baseline=-0.08cm]
            \draw[wire] circle [radius=0.3];
            \draw[thick, decorate, decoration={markings, mark =at position 1 with \arrow{stealth}}] (0.05, 0.3) -- ++ (0.01, 0);
            \node at (0, 0.35) {};
        \end{tikzpicture}
        = n.
    \end{equation}
    
    Taking the Hermitian conjugate reverses the order of the indices.
    Since indices are read anticlockwise if we take the mirror image of a tensor in the diagrammatic notation the order of the indices is reversed as anticlockwise becomes clockwise.
    So the Hermitian conjugate corresponds to the mirror image of the tensor.
    
    Given two tensors, such as \(\tensor{T}{^{abc}_{de}}\) and \(\tensor{R}{^{f}_{ghi}}\), we can form their tensor product, which has components \(\tensor{(T \otimes R)}{^{abcf}_{deghi}} = \tensor{T}{^{abc}_{de}}\tensor{R}{^f_{ghi}}\).
    Diagrammatically, this is represented by simply placing the two tensors next to each other with no indices contracted:
    \begin{equation}
        \tikzsetnextfilename{birdtracks-tensor-product}
        \begin{tikzpicture}[baseline=(T.base)]
            \node[draw, minimum width=1cm, minimum height=1.5cm] (T) {\(T\)};
            \draw[wire arrow=0.575] ($(T.west) + (0, 0.6)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(a\)};
            \draw[wire arrow=0.575] ($(T.west) + (0, 0.3)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(b\)};
            \draw[wire arrow reversed=0.425] (T.west) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(c\)};
            \draw[wire arrow reversed=0.425] ($(T.west) + (0, -0.3)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(d\)};
            \draw[wire arrow reversed=0.425] ($(T.west) + (0, -0.6)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(e\)};
            \node[draw, minimum width=1cm, minimum height=1.5cm] (R) at (2.5, 0) {\(R\)};
            \draw[wire arrow=0.575] ($(R.west) + (0, 0.6)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(f\)};
            \draw[wire arrow=0.575] ($(R.west) + (0, 0.2)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.13cm] {\(g\)};
            \draw[wire arrow=0.575] ($(R.west) + (0, -0.2)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(h\)};
            \draw[wire arrow reversed=0.425] ($(R.west) + (0, -0.6)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(i\)};
        \end{tikzpicture}
    \end{equation}
    While the tensor product is not strictly commutative it is up to isomorphism, that is there is an invertible linear map \(V \otimes W \to W \otimes V\), and this map is compatible with all of the relevant structure, and is uniquely defined.
    This means we are free to move these tensors around in the diagram, as well as the manipulation of the wires which we have been doing so far.
    
    We can express symmetries of a tensor in this notation by crossing wires to denote swapping the indices.
    For example, if \(S^{ab}\) is a symmetric tensor then we have
    \begin{equation}
        S^{ab} = 
        \tikzsetnextfilename{birdtracks-symmetric-tensor-1}
        \begin{tikzpicture}[baseline=(S.base)]
            \node[draw] (S) {\(T\)};
            \draw[wire arrow=0.575] ($(S.west) + (0, 0.15)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(a\)};
            \draw[wire arrow=0.575] ($(S.west) + (0, -0.15)$) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(b\)};
        \end{tikzpicture}
        \mkern5mu =
        \tikzsetnextfilename{birdtracks-symmetric-tensor-2}
        \begin{tikzpicture}[baseline=(S.base)]
            \node[draw] (S) {\(S\)};
            \draw[wire arrow=0.85, rounded corners] ($(S.west) + (0, -0.15)$) -- ++ (-0.3, 0) -- ++ (-0.3, 0.3) -- ++ (-0.4, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(b\)};
            \draw[wire arrow=0.85, rounded corners, over wire] ($(S.west) + (0, 0.15)$) -- ++ (-0.3, 0) -- ++ (-0.3, -0.3) -- ++ (-0.4, 0) coordinate (a) node [left, font=\scriptsize, xshift=0.1cm] {\(a\)};
        \end{tikzpicture}
        \mkern4mu = S^{ba}.
    \end{equation}
    
    We can think of the symmetry of a tensor as the action of the symmetric group on its indices.
    In general given \(V^{\otimes p} \otimes \dual{V}^{\otimes q}\), there is a natural action of \(\symmetricGroup[p] \otimes \symmetricGroup[q]\) on this space, \(\symmetricGroup[p]\) acts to permute the copies of \(V\) and \(\symmetricGroup[q]\) acts to permute the copies of \(\dual{V}\).
    In terms of the components this corresponds to permuting upper indices and permuting lower indices.
    For example, that \(S^{ab}\) is symmetric means that \(S^{ab}\) is invariant under the action of \(\cycle{1,2} \in \symmetricGroup[2]\).
    In general, a totally symmetric tensor, \(S^{a_1\dotso a_p}\), is invariant under the action of any permutation in \(\symmetricGroup[p]\).
    Likewise, a totally antisymmetric tensor, \(A^{a_1\dotso a_p}\), is invariant under any even permutation in \(\symmetricGroup[p]\) and picks up a factor of \(-1\) under any odd permutation in \(\symmetricGroup[p]\).
    
    \subsection{Birdtracks for the Symmetric Group}
    This identification of symmetries with permutations allows us to extend this notation to a notation for the symmetric group.
    We don't write any arrows, since these only tell us whether and index is contravariant or covariant, which depends on what tensor we are acting on.
    A permutation in \(\symmetricGroup\) can then be pictured as a collection of wires tracking \(n\) elements swapping around \cite[49]{cvitanovic}.
    For example, the permutation \(\cycle{1,2,4} \in \symmetricGroup[5]\) can be drawn, including labels normally left implicit, as
    \begin{equation}
        \tikzsetnextfilename{math-prelims-example-braid}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[wire] (0, 0.5) node [left] {5} -- (2.5, 0.5) node [right] {5};
            \draw[wire] (0, 1.5) node [left] {4} -- (2.5, 1.5) node [right] {4};
            \draw[underwire, rounded corners] (0, 1) -- (0.5, 1) -- (2, 2.5) -- (2.5, 2.5);
            \draw[wire, rounded corners] (0, 1) node [left] {3} -- (0.5, 1) -- (2, 2.5) -- (2.5, 2.5) node [right] {3};
            \draw[underwire, rounded corners] (0, 2.5) -- (0.5, 2.5) -- (1, 2) -- (2.5, 2);
            \draw[wire, rounded corners] (0, 2.5) node [left] {1} -- (0.5, 2.5) -- (1, 2) -- (2.5, 2) node [right] {1};
            \draw[underwire, rounded corners] (0, 2) -- (0.5, 2) -- (1.5, 1) -- (2.5, 1);
            \draw[wire, rounded corners] (0, 2) node [left] {2} -- (0.5, 2) -- (1.5, 1) -- (2.5, 1) node [right] {2};
        \end{tikzpicture}
        \ .
    \end{equation}
    
    In this notation two permutations can be composed by writing the diagrams \emph{in the opposite order to the product} and joining up the outputs of one to the inputs of the other.
    For example, the product \(\cycle{1,2,4} \cycle{3,4} = \cycle{1,2,4,3}\), viewed in \(\symmetricGroup[5]\), can be computed by connecting up the relevant diagrams:
    \begin{equation}
        \tikzsetnextfilename{math-prelims-example-diagram-composition}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[wire] (0, 0) -- (2.5, 0);
            \draw[wire] (0, 1) -- (2.5, 1);
            \draw[underwire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (2, 2) -- (2.5, 2);
            \draw[wire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (2, 2) -- (2.5, 2);
            \draw[underwire, rounded corners] (0, 2) -- (0.5, 2) -- (1, 1.5) -- (2.5, 1.5);
            \draw[wire, rounded corners] (0, 2) -- (0.5, 2) -- (1, 1.5) -- (2.5, 1.5);
            \draw[underwire, rounded corners] (0, 1.5) -- (0.5, 1.5) -- (1.5, 0.5) -- (2.5, 0.5);
            \draw[wire, rounded corners] (0, 1.5) -- (0.5, 1.5) -- (1.5, 0.5) -- (2.5, 0.5);
            \begin{scope}[xshift=3.5cm]
                \draw[wire] (0, 0) -- (1.5, 0);
                \draw[underwire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (1, 1) -- (1.5, 1);
                \draw[wire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (1, 1) -- (1.5, 1);
                \draw[wire, rounded corners] (0, 1) -- (0.5, 1) -- (1, 0.5) -- (1.5, 0.5);
                \draw[wire] (0, 1.5) -- (1.5, 1.5);
                \draw[wire] (0, 2) -- (1.5, 2);
            \end{scope}
            \node at (3, 1) {\(\circ\)};
            \node at (5.5, 1) {\(=\)};
            \begin{scope}[xshift=7.5cm]
                \draw[wire] (0, 0) -- (2.5, 0);
                \draw[wire] (0, 1) -- (2.5, 1);
                \draw[underwire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (2, 2) -- (2.5, 2);
                \draw[wire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (2, 2) -- (2.5, 2);
                \draw[underwire, rounded corners] (0, 2) -- (0.5, 2) -- (1, 1.5) -- (2.5, 1.5);
                \draw[wire, rounded corners] (0, 2) -- (0.5, 2) -- (1, 1.5) -- (2.5, 1.5);
                \draw[underwire, rounded corners] (0, 1.5) -- (0.5, 1.5) -- (1.5, 0.5) -- (2.5, 0.5);
                \draw[wire, rounded corners] (0, 1.5) -- (0.5, 1.5) -- (1.5, 0.5) -- (2.5, 0.5);
            \end{scope}
            \begin{scope}[xshift=6cm]
                \draw[wire] (0, 0) -- (1.6, 0);
                \draw[underwire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (1, 1) -- (1.6, 1);
                \draw[wire, rounded corners] (0, 0.5) -- (0.5, 0.5) -- (1, 1) -- (1.6, 1);
                \draw[wire, rounded corners] (0, 1) -- (0.5, 1) -- (1, 0.5) -- (1.6, 0.5);
                \draw[wire] (0, 1.5) -- (1.6, 1.5);
                \draw[wire] (0, 2) -- (1.6, 2);
            \end{scope}
        \end{tikzpicture}
        \ .
    \end{equation}
    We can then simplify the diagram by assuming that the wires can pass through each other and rearrange them until the diagram is more readable.
    More formally two diagrams represent the same permutation if they are equivalent up to a four-dimensional spatial isotopy, the fourth dimension allowing us to pass the wires around each other, when in three dimensions they would collide.
    This results in the following diagram:
    \begin{equation}
        \tikzsetnextfilename{math-prelims-example-diagram-simplified-composition}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[wire] (0, 0) -- (2, 0);
            \draw[underwire, rounded corners] (0, 0.5) -- (1, 0.5) -- (1.5, 1) -- (2, 1);
            \draw[wire, rounded corners] (0, 0.5) -- (1, 0.5) -- (1.5, 1) -- (2, 1);
            \draw[underwire, rounded corners] (0, 1) -- (0.5, 1) -- (1.5, 2) -- (2, 2);
            \draw[wire, rounded corners] (0, 1) -- (0.5, 1) -- (1.5, 2) -- (2, 2);
            \draw[underwire, rounded corners] (0, 1.5) -- (0.5, 1.5) -- (1.5, 0.5) -- (2, 0.5);
            \draw[wire, rounded corners] (0, 1.5) -- (0.5, 1.5) -- (1.5, 0.5) -- (2, 0.5);
            \draw[underwire, rounded corners] (0, 2) -- (1, 2) -- (1.5, 1.5) -- (2, 1.5);
            \draw[wire, rounded corners] (0, 2) -- (1, 2) -- (1.5, 1.5) -- (2, 1.5);
        \end{tikzpicture}
        \ .
    \end{equation}
    
    A common operation on tensors is to symmetrise or antisymmetrise over a certain set of indices \cite[50--51]{cvitanovic}.
    Denoting by \(S_{i_1\dotso i_k}\) the symmetriser over the indices \(i_1, \dotsc, i_k\) this symmetriser is given by
    \begin{equation}
        S_{i_1 \dotso i_k} \coloneqq \frac{1}{k!} \sum_{\sigma \in \symmetricGroup[k]} \sigma,
    \end{equation}
    where the permutations act on the \(k\) indices \(i_1, \dotsc, i_k\).
    This formal sum of permutations is an element of the group algebra, \(\complex[\symmetricGroup[k]]\).
    Similarly, the antisymmetriser is defined as
    \begin{equation}
        A_{i_1 \dotso i_k} \coloneqq \frac{1}{k!} \sum_{\sigma \in \symmetricGroup[k]} \sgn(\sigma) \sigma
    \end{equation}
    where \(\sgn\) is the sign function, defined to be 1 if \(\sigma\) can be written as a product of an even number of transpositions, and \(-1\) otherwise.
    
    For example, \(S_{12} = (\cycle{} + \cycle{1,2})/2\) and \(A_{12} = (\cycle{} - \cycle{1,2})/2\).
    Acting on a two index tensor, \(T^{ij}\), with these gives
    \begin{align}
        S_{12} \action T^{ij} &= T^{(ij)} = \frac{1}{2}(T^{ij} + T^{ji}),\\
        A_{12} \action T^{ij} &= T^{[ij]} = \frac{1}{2}(T^{ij} - T^{ji}).
    \end{align}
    
    In the braid notation we write a symmetriser as an empty box into which the wires being symmetrised are fed, and the antisymmetriser as a filled in box, so
    \begin{align}
        S_{12} &=
        \tikzsetnextfilename{math-prelims-2-symmetriser}
        \begin{tikzpicture}[baseline=(plus.base)]
            \draw[wire] (0, 0) -- (1.5, 0);
            \draw[wire] (0, 0.5) -- (1.5, 0.5);
            \draw[symmetriser] (0.5, -0.25) rectangle (1, 0.75);
            \node (plus) at (1, 0.25) {\phantom{+}};
        \end{tikzpicture}
        = \frac{1}{2} \bigg( \,
        \tikzsetnextfilename{math-prelims-2-symmetriser-expanded}
        \begin{tikzpicture}[baseline=(plus.base)]
            \draw[wire] (2.5, 0) -- (4, 0);
            \draw[wire] (2.5, 0.5) -- (4, 0.5);
            \node (plus) at (4.5, 0.25) {\(+\)};
            \draw[wire, rounded corners] (5, 0) -- (5.5, 0) -- (6, 0.5) -- (6.5, 0.5);
            \draw[underwire, rounded corners] (5, 0.5) -- (5.5, 0.5) -- (6, 0) -- (6.5, 0);
            \draw[wire, rounded corners] (5, 0.5) -- (5.5, 0.5) -- (6, 0) -- (6.5, 0);
        \end{tikzpicture}
        \, \bigg),\\
        A_{12} &=
        \tikzsetnextfilename{math-prelims-2-antisymmetriser}
        \begin{tikzpicture}[baseline=(plus.base)]
            \draw[wire] (0, 0) -- (1.5, 0);
            \draw[wire] (0, 0.5) -- (1.5, 0.5);
            \draw[antisymmetriser] (0.5, -0.25) rectangle (1, 0.75);
            \node (plus) at (1, 0.25) {\phantom{+}};
        \end{tikzpicture}
        = \frac{1}{2} \bigg( \,
        \tikzsetnextfilename{math-prelims-2-antisymmetriser-expanded}
        \begin{tikzpicture}[baseline=(plus.base)]
            \draw[wire] (2.5, 0) -- (4, 0);
            \draw[wire] (2.5, 0.5) -- (4, 0.5);
            \node (plus) at (4.5, 0.25) {\(-\)};
            \draw[wire, rounded corners] (5, 0) -- (5.5, 0) -- (6, 0.5) -- (6.5, 0.5);
            \draw[underwire, rounded corners] (5, 0.5) -- (5.5, 0.5) -- (6, 0) -- (6.5, 0);
            \draw[wire, rounded corners] (5, 0.5) -- (5.5, 0.5) -- (6, 0) -- (6.5, 0);
        \end{tikzpicture}
        \, \bigg).
    \end{align}
    
    \chapter{Young Tableaux}
    \section{Motivation}
    Recall our examples of tensors with symmetries from \cref{sec:overview}.
    We saw the Kronecker delta, \(\delta^{ij}\), is completely symmetric, the Levi-Civita symbol, \(\varepsilon^{ijk}\), and field strength tensor, \(F^{\mu\nu}\), are completely antisymmetric, and the Riemann tensor, \(R_{\mu\nu\rho\sigma}\), has mixed symmetry.
    In order to discus these we need a notation to quickly define the symmetries of a given tensor.
    These symmetries will all be of the form \enquote{some collection of indices} are symmetric (or antisymmetric) under exchange.
    
    We could start by listing all sets of indices which are symmetrised over.
    For our example tensors this gives the lists
    \begin{equation}
        \delta: [[i, j]], \quad \varepsilon: [], \quad F: [], \qand R: [[\mu\nu], [\rho\sigma]],
    \end{equation}
    where we treat \(\mu\nu\) and \(\rho\sigma\) as a single index.
    We can also list all sets of indices which are antisymmetrised over.
    For our example tensors this gives the lists
    \begin{equation}
        \delta: [], \quad \varepsilon: [[i, j, k]], \quad F: [[\mu, \nu]], \qand R: [[\mu, \nu], [\rho, \sigma]].
    \end{equation}
    
    After playing around with these lists for a bit we might notice that we can write both lists at once:
    \begin{equation}
        \delta: 
        \begin{bmatrix}
            i & j
        \end{bmatrix}
        , \quad \varepsilon: 
        \begin{bmatrix}
            i\\
            j\\
            k
        \end{bmatrix}
        , \quad F:
        \begin{bmatrix}
            \mu\\
            \nu
        \end{bmatrix}
        , \qand R: 
        \begin{bmatrix}
            \mu & \nu\\
            \rho & \sigma
        \end{bmatrix}
        .
    \end{equation}
    Here we read across to see which indices are symmetrised and down to see which indices are antisymmetrised.
    We've been trying to move away from explicitly labelling indices, so lets just take the order of the indices as it is and replace all the symbols with a blank square, \(\square\):
    \begin{equation}
        \delta: 
        \begin{bmatrix}
            \square & \square
        \end{bmatrix}
        , \quad \varepsilon: 
        \begin{bmatrix}
            \square\\
            \square\\
            \square
        \end{bmatrix}
        , \quad F:
        \begin{bmatrix}
            \square\\
            \square
        \end{bmatrix}
        , \qand R: 
        \begin{bmatrix}
            \square & \square\\
            \square & \square
        \end{bmatrix}
        .
    \end{equation}
    Finally, take away the brackets and push all the squares together and we get
    \begin{equation}
        \delta: \ydiagram{2}\,, \quad \varepsilon:\ydiagram{1,1,1}\,, \quad F: \ydiagram{1,1}\,, \qand R: \ydiagram{2,2}\,.
    \end{equation}
    The next section formalises this notation, which are called Young diagrams.
    
    \section{What are Young Diagrams}
    \begin{dfn}{Partition}{}
        Let \(k\) be a natural number.
        A \defineindex{partition} of \(k\) is a tuple, \(\tuple{\lambda_1, \dotsc, \lambda_n}\) such that \cite[720]{hassani}
        \begin{equation}
            k = \sum_{i = 1}^{n} \lambda_i.
        \end{equation}
        A partition is \define{ordered}\index{ordered partition} if \(\lambda_i \ge \lambda_{i+1}\) for all \(i = 1, \dotsc, n - 1\).
    \end{dfn}

    For example, \(\tuple{1,5,3}\) is a partition of 9, this is not ordered, the equivalent ordered partition is \(\tuple{5,3,1}\).
    
    \begin{dfn}{Young Diagram}{}
        Given an ordered partition \(\tuple{\lambda_1, \dotsc, \lambda_n}\) of some \(k \in \naturals\) the \defineindex{Young diagram} is formed from a row of \(\lambda_1\) boxes above a row of \(\lambda_2\) boxes and so on down to a row of \(\lambda_n\) boxes, all aligned to the left \cite[87]{cvitanovic}.
    \end{dfn}
    
    For example, the ordered partitions of four are \(\tuple{4}\), \(\tuple{3,1}\), \(\tuple{2,2}\), \(\tuple{2,1,1}\), and \(\tuple{1,1,1,1}\).
    The corresponding Young diagrams are
    \ytableausetup{smalltableaux}
    \begin{equation}
        \ydiagram{4}\,, \quad \ydiagram{3,1}\,, \quad \ydiagram{2,2}\,, \quad \ydiagram{2,1,1}\,, \qand \ydiagram{1,1,1,1}\,.
    \end{equation}
    
    \begin{dfn}{Young Tableaux}{}
        Given a Young diagram we form a \defineindex{Young tableau} by writing numbers in the boxes in such a way that the numbers are increasing from left to right along a row and strictly increasing from top to bottom down a column \cite{cvitanovic}.
        A \(k\) box \defineindex{standard Young tableau} is a Young tableau using the numbers 1 through \(k\) exactly once.
    \end{dfn}
    
    For example, given the Young diagram associated with the partition \(\tuple{2,1,1}\) there are three distinct standard tableaux:
    \begin{equation}
        \ytableaushort{12,3,4}, \qquad \ytableaushort{13,2,4}, \qqand \ytableaushort{14,2,3}.
    \end{equation}
        
    \begin{dfn}{Hook Number}{}
        Given a Young diagram, \(Y\), the \defineindex{hook length} of a box is the number of boxes to the right of that box, plus the number of boxes below that box, plus 1 for the box itself.
        The \defineindex{hook number}, \(\hooknumber{Y}\), is the product of the hook lengths \cite[88]{cvitanovic}.
    \end{dfn}
    \begin{exm}{}{}
        Consider the Young diagram given by the partition \(\tuple{3,2}\):
        \begin{equation}
            Y = \ydiagram{3,2}.
        \end{equation}
        The hooks of this diagram are
        \begin{equation}
            \begin{ytableau}
                *(light highlight) \strut & *(light highlight) \strut & *(light highlight) \strut \\
                *(light highlight) \strut & \strut
            \end{ytableau}
            , \quad
            \begin{ytableau}
                \strut & *(light highlight) \strut & *(light highlight) \strut \\
                \strut & *(light highlight) \strut
            \end{ytableau}
            , \quad
            \begin{ytableau}
                \strut & \strut & *(light highlight) \strut \\
                \strut & \strut
            \end{ytableau}
            , \quad
            \begin{ytableau}
                \strut & \strut & \strut \\
                *(light highlight) \strut & *(light highlight) \strut
            \end{ytableau}
            , \qand
            \begin{ytableau}
                \strut & \strut & \strut \\
                \strut & *(light highlight) \strut
            \end{ytableau}
            .
        \end{equation}
        Labelling each box with the associated hook length gives
        \begin{equation}
            \ytableaushort{431,21}.
        \end{equation}
        The hook number is
        \begin{equation}
            \hooknumber{Y} = 4 \cdot 3 \cdot 1 \cdot 2 \cdot 1 = 24.
        \end{equation}
    \end{exm}
    
    \section{Young Projectors}
    We motivated Young diagrams as a way of labelling the symmetries of a given tensor.
    We now ask the reverse question, given a Young diagram how can we construct a tensor with the given symmetries?
    For example, suppose we want to construct a tensor with the symmetries labelled by
    \begin{equation}
        \ydiagram{2,1}.
    \end{equation}
    That is, it should be symmetric in the first two indices and antisymmetric in the second two indices.
    Start with some tensor, \(T\), with the appropriate number of indices and no particular symmetry.
    So in this example we start with \(T^{ijk}\).
    We can make a tensor which is symmetric in the first pair of indices by symmetrising:
    \begin{equation}
        T_1^{ijk} = \frac{1}{2}(T^{ijk} + T^{jik}).
    \end{equation}
    We can then make a tensor which is antisymmetric in the second pair of indices by antisymmetrising:
    \begin{equation}
        T_2^{ijk} = \frac{1}{2}(T_1^{ijk} - T_1^{ikj}) = \frac{1}{4}(T^{ijk} + T^{jik} - T^{ikj} - T^{jik}).
    \end{equation}
    We can then write this as some linear combination of permutations in \(\complex[\symmetricGroup[3]]\) acting on \(T^{ijk}\):
    \begin{equation}
        T_2^{ijk} = \frac{1}{4}[\cycle{} + \cycle{1,2} - \cycle{2,3} - \cycle{1,3,2}] \action T^{ijk}.
    \end{equation}
    Generalising this procedure leads to the following definition.
    
    
    \begin{dfn}{Young Projector}{}
        Given a \(k\) box Young diagram, \(Y\), with \(r\) rows and \(c\) columns the \defineindex{Young projector}, \(\projector{Y}\) associated with \(Y\) is given by the following procedure \cite[91]{cvitanovic}:
        \begin{enumerate}
            \item Number the boxes \(1\) to \(k\) from left to right, top to bottom.
            \item Symmetrise over the numbers in each row.
            \item Antisymmetrise over the numbers in each column.
            \item Normalise by a factor of
            \begin{equation}
                \alpha_Y \coloneqq \frac{1}{\hooknumber{Y}} \left( \prod_{i=1}^{r} \abs{S_i}! \right) \left( \prod_{j=1}^{c} \abs{A_j}! \right).
            \end{equation}
            Here \(\hooknumber{Y}\) is the hook number of the diagram, \(\abs{S_i}\) is the length of the \(i\)th row and \(\abs{A_j}\) is the length of the \(j\)th column.
        \end{enumerate}
    \end{dfn}
    
    It is also possible to construct projectors from Young tableaux.
    To do so first identify the permutation, \(\sigma\), which turns the ordered Young tableau into the Young tableau that we have, then construct the Young projector for the Young diagram of this shape.
    Finally, take the product with the permutation \(\sigma\).
    Acting on a tensor with no symmetries with this Young projector first acts with the permutation \(\sigma\) before acting with the normal Young projector based on the Young diagram.
    Thus the symmetries of the resulting tensor are similar to the symmetries of the Young diagram, except instead of the index position deciding which box corresponds to which index the numbering of the boxes decides.
    
    \begin{exm}{}{}
        Consider the \(5\) box Young diagram
        \begin{equation}
            Y = \ydiagram{3,2}.
        \end{equation}
        Numbering the boxes we get
        \begin{equation}
            \ytableaushort{123,45}.
        \end{equation}
        We need to symmetrise over \(1\), \(2\) and \(3\), and \(4\) and \(5\), using \(S_{123}\) and \(S_{45}\), and antisymmetrise over \(1\) and \(4\), \(2\) and \(5\), and \(3\) on its own, using \(A_{14}\), \(A_{25}\), and \(A_{3} = \cycle{} = \identity\).
        
        The normalisation factor is
        \begin{align}
            \alpha_Y &= \frac{1}{24} (3!2!)(2!2!1!) = 6.
        \end{align}
        The Young projector is then
        \begin{equation}
            \projector{Y} = 6
            \tikzsetnextfilename{young-projector-example}
            \begin{tikzpicture}[baseline=(A)]
                \node (A) at (0, 0.9) {};
                \foreach \y in {0, 0.5, ..., 2} {
                    \draw[wire] (0, \y) -- ++ (0.5, 0);
                }
                \draw[wire, rounded corners] (1, 0) -- ++ (0.5, 0) -- ++ (0.5, 0.5) -- ++ (1.5, 0) -- ++ (0.5, -0.5) -- ++ (0.5, 0);
                \draw[wire, rounded corners] (1, 0.5) -- ++ (0.5, 0) -- ++ (0.5, 1) -- ++ (1.5, 0) -- ++ (0.5, -1) -- ++ (0.5, 0);
                \draw[underwire, rounded corners] (1, 1) -- ++ (0.5, 0) -- ++ (0.5, -1) -- ++ (1.5, 0) -- ++ (0.5, 1) -- ++ (0.5, 0);
                \draw[wire, rounded corners] (1, 1) -- ++ (0.5, 0) -- ++ (0.5, -1) -- ++ (1.5, 0) -- ++ (0.5, 1) -- ++ (0.5, 0);
                \draw[underwire, rounded corners] (1, 1.5) -- ++ (0.5, 0) -- ++ (0.5, -0.5) -- ++ (1.5, 0) -- ++ (0.5, 0.5) -- ++ (0.5, 0);
                \draw[wire, rounded corners] (1, 1.5) -- ++ (0.5, 0) -- ++ (0.5, -0.5) -- ++ (1.5, 0) -- ++ (0.5, 0.5) -- ++ (0.5, 0);
                \draw[wire, rounded corners] (1, 2) -- ++ (3.5, 0);
                
                \draw[symmetriser] (0.5, 2.15) rectangle (1, 0.85);
                \draw[symmetriser] (0.5, 0.65) rectangle (1, -0.15);
                \draw[antisymmetriser] (2.5, 2.15) rectangle (3, 1.35);
                \draw[antisymmetriser] (2.5, 1.15) rectangle (3, 0.35);
            \end{tikzpicture}
        \end{equation}
    \end{exm}
    
    Young projectors are constructed in such such a way that by the usual action of the symmetric group the Young projectors on diagrams of \(k = p + q\) form a complete set of orthogonal projection operators on \(V^{\otimes p} \otimes \dual{V}^{\otimes q}\) \cite[92]{cvitanovic}.
    Being projection operators means that \(\projector{Y} \projector{Y} = \projector{Y}\), being orthogonal means \(\projector{Y} \projector{Z} = 0\) if \(Y \ne Z\),and completeness means \(\sum_Y \projector{Y} = \cycle{} = \identity\), where the sum is over all standard tableaux with \(k\) boxes.
    The orthogonality follows immediately from the fact that if we connect a symmetriser to an antisymmetriser with two or more wires then the result must vanish, since this is the product of a symmetric and antisymmetric term.
    
    \section{Hermitian Young Projectors}
    For Young diagrams with three or more boxes the associated Young projectors are not, in general, Hermitian.
    Hermiticity is often a desirable property.
    Fortunately it is possible to construct Hermitian Young projectors from the Young projectors we already have.
    
    \begin{dfn}{Hermitian Young Projectors}{}
        Denote by \(\projector{Y}\) the Young projector associated with the Young diagram \(Y\).
        Let \(Y'\) be the Young diagram we get by removing the last box on the last row.
        Construct the following
        \begin{equation}
            \hermitianprojector{Y} \coloneqq
            \begin{cases}
                \projector{Y} & \text{if } Y \text{ has 2 or fewer boxes},\\
                (\hermitianprojector{Y'} \otimes 1) \projector{Y} (\hermitianprojector{Y'} \otimes 1) & \text{if } Y \text{ has 3 or more boxes}.
            \end{cases}
        \end{equation}
    \end{dfn}
    
    That \(\symbfup{H}_{Y}\) are Hermitian is proven in \cite{keppeler-hermitian-young-projectors}.
    
    The construction of \(\symbfup{H}_{Y}\) is clearer in the diagrammatic notation, where the recursive definition is
    \begin{equation}
        \tikzsetnextfilename{hermitian-young-projector}
        \begin{tikzpicture}[baseline=(equal.base), font=\scriptsize]
            \draw (0, -0.25) rectangle (1, 1.75) node [midway] (Ptheta) {\(P_{\Theta}\)};
            \draw[wire] (-0.5, 0) -- (0, 0);
            \draw[wire] (-0.5, 0.5) -- (0, 0.5);
            \draw[wire] (-0.5, 1.5) -- (0, 1.5);
            \node at (-0.25, 1) {\(\vdots\)};
            \draw[wire] (1, 0) -- (1.5, 0);
            \draw[wire] (1, 0.5) -- (1.5, 0.5);
            \draw[wire] (1, 1.5) -- (1.5, 1.5);
            \node at (1.25, 1) {\(\vdots\)};
            \node[right=of Ptheta] (equal) {\(=\)};
            \draw (3, 0.25) rectangle (4, 1.75) node [midway] {\(P_{\Theta'}\)};
            \draw[wire] (2.5, 0) -- (4.5, 0);
            \draw[wire] (2.5, 0.5) -- (3, 0.5);
            \draw[wire] (2.5, 1.5) -- (3, 1.5);
            \node at (2.75, 1) {\(\vdots\)};
            \draw[wire] (4, 0.5) -- (4.5, 0.5);
            \draw[wire] (4, 1.5) -- (4.5, 1.5);
            \node at (4.25, 1) {\(\vdots\)};
            \draw (4.5, -0.25) rectangle (5.5, 1.75) node [midway] {\(Y_{\Theta}\)};
            \draw[wire] (5.5, 0) -- (7.5, 0);
            \draw[wire] (5.5, 0.5) -- (6, 0.5);
            \draw[wire] (5.5, 1.5) -- (6, 1.5);
            \node at (5.75, 1) {\(\vdots\)};
            \draw (6, 0.25) rectangle (7, 1.75) node [midway] {\(P_{\Theta'}\)};
            \draw[wire] (7, 0.5) -- (7.5, 0.5);
            \draw[wire] (7, 1.5) -- (7.5, 1.5);
            \node at (7.25, 1) {\(\vdots\)};
        \end{tikzpicture}
        .
    \end{equation}
    Hermiticity in the diagrammatic notation corresponds to a vertical mirror symmetry, which is clearly present here.
    This, combined with the fact that two box Young diagrams correspond to either a single symmetriser or single antisymmetriser, which has vertical mirror symmetry, should be enough to demonstrate Hermiticity.
    
    % TODO: Example of Hermitian Young projector construction
    
    \section{Garnir Relations}
    \subsection{Motivation}
    The standard Young tableaux of a given shape, or rather the associated Young projectors, form a basis for the Young projectors formed from Young tableaux of that shape.
    This is useful since it restricts the number of projectors which we need to compute, allowing for more efficient computations.
    
    The \defineindex{Garnir relations} give us a way of taking a projector corresponding to a nonstandard Young tableau and writing it as a sum of projectors corresponding to standard Young tableaux of the same shape.
    While the relations are on the level of the Young projectors, which are elements of the group algebra, \(\complex[\symmetricGroup]\), they are applied on the level of the Young tableaux.
    So just keep in mind that whenever we write a sum of two Young tableaux the sum is actually happening one layer down in the group algebra.
    
    The Garnir relations work by taking a symmetriser, which on the level of Young tableaux is just a row of boxes.
    We then apply this to the Young tableau, and there are only so many ways that this can be done without getting zero, since we cannot connect multiple any antisymmetriser to this symmetriser by more than one wire for a non-zero result.
    We choose this symmetriser such that it involves symmetrising over indices which the projector antisymmetrises, and so the result is zero overall.
    This allows us to write a Young tableau as a sum of Young tableau which are closer to being standard Young tableau, in the sense that the position in the Young tableau at which it first fails to be standard moves right is found further right or further down in all of the other Young tableaux in the sum.
    We can then rearrange this sum to find our initial Young tableau in terms of these closer-to-standard tableaux.
    If any non-standard tableau remains in this sum simply apply the Garnir relations to this tableau until there are no non-standard tableaux.
    Since the tableaux are all of finite extent this process must eventually terminate.
    
    \subsection{Applying the Garnir Relations}
    We start with a non-standard \(k\) box Young tableau.
    The Garnir relations are best expressed through an example.
    Suppose we have the 11 box non-standard Young tableau
    \begin{equation}
        Y = \ytableaushort{1256,38{10},47,9{11}}.
    \end{equation}
    Since a Young projector involves symmetrising over a row the order of the numbers in a row is not important, so we can always sort them in increasing order.
    The numbers in each row are already sorted in increasing order here, but if they weren't then doing so would be the first step.
    The next step to applying the Garnir relations is to identify the first space, from top left going left to right top to bottom, where the tableau fails to be standard.
    In our example this is the 8 which is above a 7.
    We then highlight from this point to the point directly below it:
    \begin{equation}
        \begin{ytableau}
            1 & 2 & 5 & 6\\
            3 & *(light highlight) 8 & *(light highlight) 10\\
            *(light highlight) 4 & *(light highlight) 7\\
            9 & 11
        \end{ytableau}
    \end{equation}
    This gives us a strip of values, \(\tuple{8,10,4,7}\).
    However, we want to think of this strip not by the numbers in the boxes but the numbers of the boxes when labelled \(1\) to \(k\):
    \begin{equation}
        \begin{ytableau}
            1 & 2 & 3 & 4\\
            5 & *(light highlight) 6 & *(light highlight) 7\\
            *(light highlight) 8 & *(light highlight) 9\\
            10 & 11
        \end{ytableau}
        .
    \end{equation}
    So the boxes highlighted above are \(6\), \(7\), \(8\), and \(9\).
    
    The next step is to perform all permutations of this strip which give distinct Young projectors.
    Since we can always swap boxes in a row we simply look for all permutations of this strip which don't involve exchanging values within a row.
    In this case these swaps are
    \begin{equation}
        \cycle{6,8}, \quad \cycle{6,9}, \quad \cycle{7,8}, \quad \cycle{7,9}, \qand \cycle{6,8}\cycle{7,9}.
    \end{equation}
    These permutations act on the Young tableau by permuting the values in the boxes according to the box numbers.
    This gives us the tableaux
    \ytableausetup{smalltableaux}
    \begin{alignat}{3}
        \cycle{6,8} \action Y &=
        \ytableaushort{1256,34{10},87,9{11}}, \qquad &
        \cycle{6,8} \action Y &=
        \ytableaushort{1256,37{10},48,9{11}}, \qquad &
        \cycle{7,8} \action Y &=
        \ytableaushort{1256,384,{10}7,9{11}}, \notag\\
        \cycle{7,9} \action Y &=
        \ytableaushort{1256,387,4{10},9{11}}, \qquad &
        \cycle{6,8}\cycle{7,9} \action Y &=
        \ytableaushort{1256,347,8{10},9{11}}.
    \end{alignat}
    We can again sort all of the rows, giving
    \begin{alignat}{3}
        \cycle{6,8} \action Y &=
        \ytableaushort{1256,34{10},78,9{11}}, \qquad &
        \cycle{6,8} \action Y &=
        \ytableaushort{1256,37{10},48,9{11}}, \qquad &
        \cycle{7,8} \action Y &=
        \ytableaushort{1256,348,7{10},9{11}}, \notag\\
        \cycle{7,9} \action Y &=
        \ytableaushort{1256,378,4{10},9{11}}, \qquad &
        \cycle{6,8}\cycle{7,9} \action Y &=
        \ytableaushort{1256,347,8{10},9{11}}.
    \end{alignat}
    The Garnir relations then tell us that
    \begin{align}
        0 &= Y + \cycle{6,8} \action Y + \cycle{6,8} \action Y + \cycle{7,8} \action Y + \cycle{7,9} \action Y + \cycle{6,8}\cycle{7,9} \action Y\\
        &= \ytableaushort{1256,38{10},47,9{11}} + \ytableaushort{1256,34{10},78,9{11}} + \ytableaushort{1256,37{10},48,9{11}} + \ytableaushort{1256,348,7{10},9{11}} + \ytableaushort{1256,378,4{10},9{11}} + \ytableaushort{1256,347,8{10},9{11}}. \notag
    \end{align}
    Thus, we can write the initial non-standard Young tableau as
    \begin{align}
        Y &= -\cycle{6,8} \action Y - \cycle{6,8} \action Y - \cycle{7,8} \action Y - \cycle{7,9} \action Y - \cycle{6,8}\cycle{7,9} \action Y\\
        &= -\ytableaushort{1256,34{10},78,9{11}} - \ytableaushort{1256,37{10},48,9{11}} - \ytableaushort{1256,348,7{10},9{11}} - \ytableaushort{1256,378,4{10},9{11}} - \ytableaushort{1256,347,8{10},9{11}}.
    \end{align}
    
    At this point there are two possibilities, if all of the Young tableaux appearing on the right are standard, as is the case here, then we are finished.
    If one or more is not standard then the first point at which it fails to be standard will have moved right and/or down, meaning it is, in a sense, closer to being standard.
    We can then apply the Garnir relations to this tableau and the failure point will once again move right and/or down.
    Since tableau are finite eventually this process must terminate and we will be left with only standard tableau.
    
    To summarise, the process of writing a non-standard tableau in terms of standard tableau is as follows:
    \begin{enumerate}
        \item Sort the rows of the tableau into ascending order, if the result is a standard tableau stop here.
        \item Identify the first point from the top left going left to right and top to bottom where the tableau fails to be standard.
        \item Identify a strip going from this point to the box under this point.
        \item Apply all permutations to this strip which result in distinct tableau.
        \item The original tableau is then the negative of the sum of these permuted tableau.
        \item If any of the tableau in this sum are non-standard recursively apply the Garnir relations.
        When no non-standard tableau remain stop.
    \end{enumerate}
    Another example, where the Garnir relations are applied recursively, is in \cref{app:garnir example}
    
    \chapter{Irreducible Representations of The Symmetric Group}
    \section{Irreducible Representations of \texorpdfstring{\(\symmetricGroup\)}{Sn} are Labelled by Young Diagrams}
    Given a group, \(G\), we can define an equivalence relation, \(\sim\), where \(g \sim g'\) if and only if there exists some \(h \in G\) such that \(g = hg'h^{-1}\).
    If this is the case we say that \(g\) and \(g'\) are conjugates.
    We can then take the equivalence classes, in this context called \defineindex{conjugacy classes}, and these partition \(G\).
    
    Consider the particular case when \(G = \symmetricGroup\) is the symmetric group.
    Any permutation can be written as a product of disjoint cycles, that is cycles where no number appears in more than one cycle \cite{conjugacy-classes-cycle-types}.
    We can further order the cycles in decreasing order, and add in any element not appearing in a cycle in a singleton cycle, \(\cycle{k}\), which sends \(k\) to \(k\) and doesn't change anything else, so it is just the identity, \(\cycle{}\).
    This standard form is unique up to order of the cycles in the product and cyclic permutations of the elements within any given cycle.
    We can then define the \defineindex{cycle type} of this permutation to be the lengths of the cycles when written in this standard form.
    For example, the permutation \(\sigma = \cycle{1,2}\cycle{3,5} \in \symmetricGroup[5]\) has standard form \(\cycle{1,2}\cycle{3,5}\cycle{4}\), which has cycle type \(\tuple{2,2,1}\).
    Since every number from 1 to \(n\) appears in exactly one cycle the cycle type is a partition of \(n\).
    It can then be shown that two permutations are conjugate if and only if they have the same cycle type \cite{conjugacy-classes-cycle-types}.
    
    Fix some representation, \(\rho \colon G \to \generalLinear(V)\), for a finite dimensional vector space \(V\) over a field \(\field\).
    The \defineindex{character} of \(\rho\) is the map \(\chi_\rho\colon G \to \field\) given by \(\chi_\rho(g) = \tr(\rho(g))\).
    It is a basic result of character theory that given a conjugacy class, \([g]\), all elements of this conjugacy class have the same character, \(\chi_\rho(g)\), in a fixed representation. % TODO: Citation for this "basic result"
    This follows directly from the cyclic property of the trace and the fact that \(\rho\) is a group homomorphism.
    
    The character table of a group has columns labelled by conjugacy classes, and rows labelled by irreducible representations of the group.
    The entries into the table are then the characters associated with the conjugacy class labelling the column in the representation labelling the row.
    It can be shown that the character table is always a square \cite{zhenheng}.
    That is, there are as many irreducible representations as there are conjugacy classes.
    
    The culmination of these definitions and observations is that there is one irreducible representation of \(\symmetricGroup\) for every conjugacy class, one conjugacy class for every cycle type, one cycle type for every partition of \(n\), and one partition of \(n\) for every \(n\) box Young diagram.
    Hence there is a one-to-one correspondence between irreducible representations of \(\symmetricGroup\) and \(n\) box Young diagrams.
    So we can use \(n\) box Young diagrams to label irreducible representations of \(\symmetricGroup\).
    This turns out to be more than just a useful naming system, we will show in \cref{sec:computing representations of Sn} how using a Young diagram, and the associated Young projector, we can construct the representation it labels.
    
    \section{Elements of \texorpdfstring{\(\symmetricGroup\)}{Sn} Labelled by Young Tableaux}
    Consider \(\symmetricGroup\) and fix some \(n\) box Young diagram, \(Y\).
    The identity permutation can be represented by the Young tableau of shape \(Y\) with the numbers 1 through \(n\) entered in order from left to right, top to bottom.
    For example, if we consider \(\symmetricGroup[5]\) and the Young diagram
    \begin{equation}
        Y = \ydiagram{3,2}
    \end{equation}
    then the identity permutation, \(\cycle{}\), is represented by
    \begin{equation}
        Y_{\cycle{}} = \ytableaushort{123,45}.
    \end{equation}
    
    Another permutation, \(\sigma \in \symmetricGroup\), can then act on this Young tableau by permuting the numbers in the boxes.
    For example, \(\cycle{1,2}\cycle{3,4}\) acts on the ordered Young tableaux \(Y_{\cycle{}}\) to give
    \begin{equation}
        Y_{\cycle{1,2}\cycle{3,4}} = \cycle{1,2}\cycle{3,4}\action \ytableaushort{123,45} = 
        \ytableaushort{214,35}.
    \end{equation}
    This action defines a bijection between \(\symmetricGroup\) and the set of all Young tableaux of shape \(Y\).
    Thus, there is a one-to-one correspondence between permutations and Young tableaux of a fixed shape, so we can label permutations with Young tableau of a fixed shape.
    The obvious shape to choose is the shape corresponding to the diagram labelling the representation we are interested in working in.
    
    \section{Dimension of the Representation}
    Let \(Y\) be an \(n\) box Young diagram labelling the irreducible representation \(\rho_Y\colon \symmetricGroup \to \generalLinear(V_Y)\) of the symmetric group \(\symmetricGroup\).
    It is possible to show that the dimension of \(V_Y\) is equal to the number of standard Young tableaux of shape \(Y\).
    This number can in turn be computed using the \defineindex{hook formula}, which tells us that the number of standard tableaux of shape \(Y\), \(d_Y\), is given by
    \begin{equation}
        d_Y = \frac{n!}{\hooknumber{Y}} = \dim V_Y.
    \end{equation}
    
    % TODO: Put a citation for a proof of the hook formula, or multiple proofs since there are many ways to prove it?
    For example, the Young diagram
    \begin{equation}
        Y = \ydiagram{3,2}
    \end{equation}
    has the following five standard tableaux:
    \begin{equation}
        \ytableaushort{123,45}, \qquad \ytableaushort{124,35}, \qquad \ytableaushort{125,34}, \qquad \ytableaushort{134,25}, \qqand \ytableaushort{135,24}.
    \end{equation}
    The hook number, \(\hooknumber{Y}\), is \(4 \cdot 3 \cdot 2 = 24\).
    Thus the hook formula predicts that there are
    \begin{equation}
        d_Y = \frac{5!}{24} = 5
    \end{equation}
    standard tableaux of this shape, which agrees with what we've written down.
    
    What this tells us is that there is a one-to-one correspondence between standard Young tableau of a given shape and a basis for the representation space associated with that shape.
    We will make use of this in the next section when it comes to actually computing the representations of \(\symmetricGroup\).
    
    These relations between Young diagrams and tableaux and the representation theory of the symmetric group are summarised in \cref{fig:one-to-one relations in Sn}.
    
    \begin{figure}
        \tikzexternaldisable
        \begin{tabular}{c}
            \begin{tikzcd}
                & \text{conjugacy classes of \(\symmetricGroup\)} \arrow[r, <->] & \text{cycle types} \arrow[dd, <->] \\
                \text{irreps of \(\symmetricGroup\)} \arrow[ur, <->] \arrow[dr, <->] && \\
                & \text{\(n\) box Young diamgrams} \arrow[r, <->] & \text{partitions of \(n\)}
            \end{tikzcd}
            \\[10ex]
            \begin{tikzcd}
                \text{elements of \(\symmetricGroup\)} \arrow[r, <->] & \text{\(n\) box Young tableau of a given shape}
            \end{tikzcd}
            \\[2ex]
            \begin{tikzcd}
                \text{standard tableaux of shape \(Y\)} \arrow[r, <->] & \text{basis vectors of \(V_Y\)}
            \end{tikzcd}
        \end{tabular}
        \tikzexternalenable
        \caption{One-to-one relations between various concepts relating to Young diagrams and tableaux, and representations of \(\symmetricGroup\).}
        \label{fig:one-to-one relations in Sn}
    \end{figure}
    
    
    \section{Computing Representations of \texorpdfstring{\(\symmetricGroup\)}{Sn}}\label{sec:computing representations of Sn}
    The question now is given some \(\sigma \in \symmetricGroup\) and some \(n\) box Young diagram, \(Y\), how do we find the matrix corresponding to \(\sigma\) in the representation labelled by \(Y\)\kern0.1em?
    We'll demonstrate the procedure by computing \(\sigma = \cycle{1,3}\) in the representation labelled by the Young diagram
    \begin{equation}
        Y = \ydiagram{2,1}.
    \end{equation}
    Start by identifying this Young diagram with the ordered Young tableau of the same shape:
    \begin{equation}
        Y_{\cycle{}} = \ytableaushort{12,3}.
    \end{equation}
    
    The dimension of the representation is given by the number of standard tableaux of the same shape as \(Y\).
    The hook formula gives the dimension
    \begin{equation}
        d_Y = \frac{3!}{3} = 2,
    \end{equation}
    and indeed, there are two standard Young tableaux of this shape:
    \begin{equation}
        \ytableaushort{12,3}, \qqand \ytableaushort{13,2}.
    \end{equation}
    From each of these standard tableaux we can identify a \defineindex{standard permutation}, the permutation which acts on \(Y_{\cycle{}}\) to give the standard tableau, in this case the standard permutations are \(\cycle{}\) and \(\cycle{2,3}\).
    
    We now need the Young projector associated with \(Y\):
    \begin{equation}
        \projector{Y} = \frac{4}{3} \,
        \tikzsetnextfilename{rep-of-Sn-example-Young-projector}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (0, 1) -- (0.5, 1);
            \draw[wire] (0, 0.5) -- (0.5, 0.5);
            \draw[wire] (1, 1) -- (2.5, 1);
            \draw[wire] (3, 1) -- (4.5, 1);
            \draw[wire, rounded corners] (0, 0) -- (1.5, 0) --  (2, 0.5) -- (2.5, 0.5);
            \draw[wire, rounded corners] (3, 0.5) -- (3.5, 0.5) -- (4, 0) -- (4.5, 0);
            \draw[underwire, rounded corners] (1, 0.5) -- (1.5, 0.5) -- (2, 0) -- (3.5, 0) -- (4, 0.5) -- (4.5, 0.5);
            \draw[wire, rounded corners] (1, 0.5) -- (1.5, 0.5) -- (2, 0) -- (3.5, 0) -- (4, 0.5) -- (4.5, 0.5);
            \draw[symmetriser] (0.5, 0.25) rectangle (1, 1.25);
            \draw[antisymmetriser] (2.5, 0.25) rectangle (3, 1.25);
        \end{tikzpicture}
        =
        \tikzsetnextfilename{rep-ofSn-example-Young-projector-short-form}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (0, 1) -- (0.5, 1);
            \draw[wire] (0, 0.5) -- (0.5, 0.5);
            \draw[wire] (0, 0) -- (0.5, 0);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        .
    \end{equation}
    If we act on the left of this projector with our two standard permutations we get the following two projectors
    \begin{equation}
        \cycle{} \action \projector{Y} = \projector{Y} = \ve{1}, \qqand \cycle{2,3} \action \projector{Y} = 
        \tikzsetnextfilename{rep-of-Sn-second-basis-element}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (-0.5, 1) -- (0, 1) -- (0.5, 1);
            \draw[wire, rounded corners] (-0.5, 0) -- (-0.25, 0) -- (0.25, 0.5) -- (0.5, 0.5);
            \draw[underwire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        = \ve{2}.
    \end{equation}
    These two projectors form a basis, \(\{\ve{1}, \ve{2}\}\), for our representation space.
    Next act on this basis with \(\sigma = \cycle{1,3}\).
    First acting on \(\ve{1}\) gives
    \begin{align}
        \cycle{1,3} \action \ve{1} &=
        \tikzsetnextfilename{rep-of-Sn-step-1}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire, rounded corners] (-0.5, 1) -- (-0.25, 1) -- (0.25, 0) -- (0.5, 0);
            \draw[underwire] (-0.5, 0.5) -- (0.5, 0.5);
            \draw[wire] (-0.5, 0.5) -- (0.5, 0.5);
            \draw[underwire, rounded corners] (-0.5, 0) -- (-0.25, 0) -- (0.25, 1) -- (0.5, 1);
            \draw[wire, rounded corners] (-0.5, 0) -- (-0.25, 0) -- (0.25, 1) -- (0.5, 1);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        =
        \tikzsetnextfilename{rep-of-Sn-step-2}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (0, 1) -- (0.5, 1);
            \draw[wire] (0, 0.5) -- (0.5, 0.5);
            \draw[wire] (0, 0) -- (0.5, 0);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{32,1}};
        \end{tikzpicture}
        =
        \tikzsetnextfilename{rep-of-Sn-step-3}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (0, 1) -- (0.5, 1);
            \draw[wire] (0, 0.5) -- (0.5, 0.5);
            \draw[wire] (0, 0) -- (0.5, 0);
            \draw[wire] (2.5, 1) -- (3, 1);
            \draw[wire] (2.5, 0.5) -- (3, 0.5);
            \draw[wire] (2.5, 0) -- (3, 0);
            \draw (0.5, -0.25) rectangle (2.5, 1.25);
            \node at (1.5, 0.5) {-\,\ytableaushort{12,3} \, - \ytableaushort{13,2}};
        \end{tikzpicture}
        \notag\\
        &= -
        \tikzsetnextfilename{rep-of-Sn-step-4}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (0, 1) -- (0.5, 1);
            \draw[wire] (0, 0.5) -- (0.5, 0.5);
            \draw[wire] (0, 0) -- (0.5, 0);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        -
        \tikzsetnextfilename{rep-of-Sn-step-5}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (-0.5, 1) -- (0, 1) -- (0.5, 1);
            \draw[wire, rounded corners] (-0.5, 0) -- (-0.25, 0) -- (0.25, 0.5) -- (0.5, 0.5);
            \draw[underwire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        = -\ve{1} - \ve{2}.
    \end{align}
    Here we have acted on the inputs to the Young projector.
    Then interpreted this as acting by permutations on the underlying Young tableau.
    We then decomposed the permuted Young tableau into a sum of standard tableaux using the Garnir relations.
    Finally we take this linear combination of standard tableaux and replace each standard tableaux with the corresponding standard permutation acting on the ordered tableau.
    Thus we are left with a linear combination of standard permutations acting on the Young projector associated with the Young diagram \(Y\).
    We then interpret this as a sum of basis vectors in the representation space.
    
    We can do exactly the same with the second basis vector to get
    \begin{align}
        \cycle{1,3} \action \ve{2} &= 
        \tikzsetnextfilename{rep-of-Sn-step-6}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire, rounded corners] (-1.5, 1) -- (-1.25, 1) -- (-0.75, 0) -- (-0.5, 0) -- (-0.25, 0) -- (0.25, 0.5) -- (0.5, 0.5);
            \draw[underwire, rounded corners] (-1.5, 0.5) -- (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire, rounded corners] (-1.5, 0.5) -- (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[underwire, rounded corners] (-1.5, 0) -- (-1.25, 0) -- (-0.75, 1) -- (0.5, 1);
            \draw[wire, rounded corners] (-1.5, 0) -- (-1.25, 0) -- (-0.75, 1) -- (0.5, 1);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        =
        \tikzsetnextfilename{rep-of-Sn-step-7}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire, rounded corners] (-0.5, 0) -- (-0.25, 0) -- (0.25, 1) -- (0.5, 1);
            \draw[underwire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[underwire, rounded corners] (-0.5, 1) -- (-0.25, 1) -- (0.25, 0.5) -- (0.5, 0.5);
            \draw[wire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire, rounded corners] (-0.5, 1) -- (-0.25, 1) -- (0.25, 0.5) -- (0.5, 0.5);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        \\
        &=
        \tikzsetnextfilename{rep-of-Sn-step-8}
        \begin{tikzpicture}[baseline=0.42cm]
            \draw[wire] (-0.5, 1) -- (0, 1) -- (0.5, 1);
            \draw[wire, rounded corners] (-0.5, 0) -- (-0.25, 0) -- (0.25, 0.5) -- (0.5, 0.5);
            \draw[underwire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire, rounded corners] (-0.5, 0.5) -- (-0.25, 0.5) -- (0.25, 0) -- (0.5, 0);
            \draw[wire] (1.5, 1) -- (2, 1);
            \draw[wire] (1.5, 0.5) -- (2, 0.5);
            \draw[wire] (1.5, 0) -- (2, 0);
            \draw (0.5, -0.25) rectangle (1.5, 1.25);
            \node at (1, 0.5) {\ytableaushort{12,3}};
        \end{tikzpicture}
        = \ve{2}.
    \end{align}
    In the last step we identified that the projector is symmetric in the first two inputs, since these are symmetrised over.
    So, we are free to swap the first two input wires, which leaves us with \(\ve{2}\).
    If we hadn't seen that this was possible then we could have applied the permutation to the Young tableau as we did for the first term, and then decomposed the result with the Garnir relations, and the answer would be the same, it's just slower.
    
    Now we have seen how this permutation, \(\cycle{1,3}\), acts on the basis vectors, \(\{\ve{1}, \ve{2}\}\), we can extend this by linearity to the whole representation space.
    We can then write this action as a matrix equation and read off the entries of the matrix.
    The one subtlety is that we placed the permutations on the left of the Young projector, but this corresponds to multiplying on the right by the permutation, so we act on the right with the matrix.
    Thus, we can find the representation of \(\cycle{1,3}\) by finding the matrix \(\rho\cycle{1,3}\) in the following
    \begin{equation}
        \begin{pmatrix}
            \ve{1} & \ve{2}
        \end{pmatrix}
        \rho\cycle{1,3} = 
        \begin{pmatrix}
            -\ve{1} - \ve{2} & \ve{2}
        \end{pmatrix}
        \implies \rho\cycle{1,3} = 
        \begin{pmatrix}
            -1 & 0\\
            -1 & 1
        \end{pmatrix}
        .
    \end{equation}

    To summarise the process given some permutation \(\sigma \in \symmetricGroup\) and an \(n\) box Young diagram, \(Y\), labelling a representation we can find the action of \(\sigma\) in this representation as follows:
    \begin{enumerate}
        \item Write down the \(d_Y = n!/\hooknumber{Y}\) standard tableaux of the same shape, these give the standard permutations, \(\tau_i\).
        \item Act on the Young projector, \(\projector{Y}\), with the standard permutations to get the basis elements, \(\ve{i} = \tau_i \action \projector{Y}\).
        \item Act on each basis element with the permutation, \(\sigma \action \ve{i}\).
        \item Simplify the result using Garnir relations until the result is written in terms of \(\ve{i}\).
        \item Solve the equation
        \begin{equation}
            \begin{pmatrix}
                \ve{1} & \cdots & \ve{d}
            \end{pmatrix}
            \rho(\sigma) = 
            \begin{pmatrix}
                \sigma \action \ve{1} & \cdots & \sigma \action \ve{d}
            \end{pmatrix}
        \end{equation}
        for the \(d \times d\) representation matrix, \(\rho(\sigma)\).
    \end{enumerate}
    
    Notice that at no point in this process did we ever actually have to use the Young projector, all we used were the symmetries it posses, and we didn't even need to use these, they just speed things up.
    The only property of the Young diagram we use are the standard Young tableaux and the Garnir relations.
    
    It is important that we don't have to use the Young projector in this computation because computations with Young projectors in diagrammatic notation cannot be done efficiently on a computer.
    However, we can implement the Garnir relations and follow this procedure to compute the representation of a permutation.
    We can then extend this process to any element of the group algebra \(\complex[\symmetricGroup]\) by extending the group homomorphism \(\rho\colon \symmetricGroup \to \generalLinear(V)\) to an algebra homomorphism \(\complex[\symmetricGroup] \to \generalLinear(V)\).
    This allows us to compute the representation of Young projectors.
    This is useful since we can then efficiently perform calculations on a computer using these matrix representations.
    
    \chapter{Applications to \texorpdfstring{\(\specialUnitary(N)\)}{SU(N)}}
    Recall that the special unitary group, \(\specialUnitary(N)\), is defined to be the group of unitary \(N \times N\) matrices with determinant 1.
    In this section we will focus on the representation theory of \(\specialUnitary(N)\) with a goal of computing scalars, quantities invariant under \(\specialUnitary(N)\)/
    The motivation for studying \(\specialUnitary(N)\) is its prevelance in quantum field theory, particularly as \(\specialUnitary(3)\) in quantum chromodynamics and \(\specialUnitary(2)\) in electroweak theory.
    
    \section{\texorpdfstring{\(\specialUnitary(N)\)}{SU(N)} in Quantum Field Theory}
    A gauge theory is a quantum field theory with a local symmetry of the fields.
    A local symmetry in turn is an action of some group, \(G\), on the fields which may depend on the position at which the field is evaluated, such that the Lagrangian is left invariant under this group action.
    The prototypical example of a gauge theory is electromagnetism, where the gauge group is \(\unitary(1)\), and the symmetry is given by \(\psi \mapsto \e^{i\alpha}\psi\) for some \(\alpha \in \reals\).
    
    Of more interest to us here are \(\specialUnitary(N)\) gauge theories.
    We will focus on quantum chromodynamics, the gauge theory of the strong force, which is an \(\specialUnitary(3)\) gauge theory.
    Here the 3 is the number of colours.
    The two most important particles in quantum chromodynamics are quarks and gluons.
    Quarks are fermions, meaning they are represented by spinors, whereas gluons are vector bosons, meaning they are represented by four-vector quantities.
    As well as being in some spinor or Minkowski space, both of which are just representation spaces of \(\specialOrthogonal^+(1, 3)\) capturing the Lorentz transformations of the fields, quarks and gluons are also elements of some vector space transforming under \(\specialUnitary(3)\).
    In particular, quarks are in the fundamental representation, which is three dimensional so is often denoted \(\rep{3}\).
    Gluons are in the adjoint representation, which is eight dimensional, so is often denoted \(\rep{8}\).
    
    \section{Representations of \texorpdfstring{\(\specialUnitary(N)\)}{SU(N)}}
    The irreducible representations of the unitary group, \(\unitary(N)\), can be labelled with \(k\) box standard Young tableaux with no more than \(N\) rows.
    The reason is that we interpret a \(k\) box diagram as a \(k\) index tensor, which we in turn interpret as a product of \(k\) vectors, each giving the state of a particle.
    So, a \(k\) box Young tableau corresponds to a \(k\) particle state.
    Since \(\unitary(N)\) has \(N\) labels for the particles, generalising the 3 colour labels of \(\specialUnitary(3)\) or single charge label of \(\unitary(1)\), we cannot antisymmetrise over more than \(N\) boxes without getting zero.
    
    Moving to \(\specialUnitary(N)\) we add the restriction that the determinant is 1.
    This means that we have an extra invariant tensor compared to \(\unitary(N)\), namely the Levi--Civita.
    Contracting with the Levi--Civita tensor we can remove any column of length \(N\).
    This means that representations of \(\specialUnitary(N)\) can be labelled with \(k\) box standard Young tableaux with no more than \(N - 1\) rows.
    
    Given a Young diagram, \(Y\), labelling a representation \(V\) of \(\specialUnitary(N)\) the dimension of \(V\) is given by \(\tr(\projector{Y})\) where \(\projector{Y}\) is the Young projector associated with \(Y\).
    The dimension can also be calculated without computing the Young projector using the formula
    \begin{equation}\label{eqn:dim of SU N rep}
        \dim V = \frac{f_Y(N)}{\hooknumber{Y}}.
    \end{equation}
    Here \(f_Y\) is a polynomial in \(N\) given by placing \(N\) in the top left box of \(Y\), then increasing by one with each box to the right.
    On the second row start with \(N - 1\) and increase going right as before.
    On the third row start with \(N - 2\) and so on.
    
    For example, consider
    \begin{equation}
        \ytableausetup{nosmalltableaux}
        Y = \ytableaushort{{\scriptscriptstyle N}{\scriptscriptstyle N+1}{\scriptscriptstyle N+2}{\scriptscriptstyle N+3},{\scriptscriptstyle N-1}{\scriptscriptstyle N},{\scriptscriptstyle N-2}} \implies f_Y(N) = N^2(N + 1)(N + 2)(N + 3)(N - 1)(N - 2)
        \ytableausetup{smalltableaux}
    \end{equation}
    which has hook number \(\hooknumber{Y} = 144\).
    This labels a representation with dimension
    \begin{equation}
        \frac{N^2(N^2 - 1)(N^2 - 4)(N + 3)}{144}.
    \end{equation}
    Less abstractly, work in \(\specialUnitary(3)\) and consider the diagrams
    \begin{equation}
        Y_1 = \ydiagram{1}, \qqand Y_2 = \ydiagram{2,1}.
    \end{equation}
    We have
    \begin{align}
        f_{Y_1}(N) &= N &&\implies f_{Y_1}(3) = 3, \qqand\\
        f_{Y_2}(N) &= N(N + 1)(N - 1) &&\implies f_{Y_2}(3) = 24.
    \end{align}
    Thus these label representations with dimensions
    \begin{equation}
        \frac{3}{1} = 3, \qqand \frac{24}{3} = 8.
    \end{equation}
    That is, these label \(\rep{3}\) and \(\rep{8}\), so correspond to quarks and gluons.
    
    \section{Computing Scalars}
    A scalar has no indices.
    Thus in the diagrammatic notation it corresponds to a quantity with no external legs.
    Scalars are invariant under the group action.
    This means that these are exactly the objects we are interested in for building the Lagrangian of a field theory.
    We present here a general method for simplifying scalars in \(\specialUnitary(N)\) until they are reduced to a few simple building blocks, which can then be dealt with by computing Young projectors.
    
    That Young projectors are relevant to \(\specialUnitary(N)\) may be surprising, since we first constructed them when discussing the symmetric group.
    However, since Young tableaux label the irreducible representations of \(\specialUnitary(N)\) we can also construct and interpret Young projectors in \(\specialUnitary(N)\).
    Here the understanding of the symmetrisers and antisymmetrisers is that they describe the symmetry of exchanging particles, with a \(k\) box Young diagram corresponding to a \(k\) particle state.
    
    Even more useful is the fact that we don't actually need to compute the Young projectors in \(\specialUnitary(N)\), only in \(\symmetricGroup\).
    We've already seen how to compute the representation of Young projectors in \(\symmetricGroup\), so once we have reduced a scalar to some combination of Young projectors we are finished.
    
    The general procedure for doing this is based on sections 4.2, 5.1, and 5.2 of \cite{cvitanovic}.
    The following sections summarise the key parts of these sections and add in additional explanations.
    
    \subsection{Projectors}
    Consider a \(d \times d\) Hermitian matrix \(M\) acting on the space \(d = n^{p + q}\) dimensional space \(\symcal{V} = V^{\otimes p} \otimes \dual{V}^{\otimes q}\), with \(n = \dim V\).
    This can be diagonalised by some unitary matrix, \(D\), then we have
    \begin{equation}
        DMD^{\hermit} = 
        \begin{pmatrix}
            \lambda_1\identityMatrix_{V_1} & & \\
            & \ddots & \\
            & & \lambda_k\identityMatrix_{V_k}
        \end{pmatrix}
    \end{equation}
    where \(\lambda_i\) are the eigenvalues of \(M\) and \(\identityMatrix_{V_i}\) are the identity matrices on the eigenspaces \(V_i\), which are the subspaces of \(V\) such that \(Mv = \lambda_iv\) for all \(v \in V_i\).
    Now consider \(D(M - \lambda_i\identityMatrix_V)D^{\hermit}\).
    By construction this has the same eigenspaces as \(M\), but the eigenspace corresponding to \(\lambda_i\) now has eigenvalue zero.
    The eigenvalues on the eigenspace \(V_j\) are then shifted to \(\lambda_j - \lambda_i\).
    Take a product of these terms over all but one eigenspace.
    The result is
    \begin{equation}
        D \prod_{\substack{j = 1\\ j \ne i}}^{k} (M - \lambda_i\identityMatrix_{\symcal{V}})D^\hermit = \prod_{\substack{j=1\\ j \ne i}} (\lambda_i - \lambda_j)
        \begin{pmatrix}
            0\identityMatrix_{V_1} \\
            & \ddots \\
            && \identityMatrix_{V_i} \\
            &&& \ddots \\
            &&&& 0\identityMatrix_{V_k}
        \end{pmatrix}
        .
    \end{equation}
    We can identify the matrix here as being the projection operator onto the \(V_i\) subspace.
    Then we can write the projection operator as
    \begin{equation}
        \projector{i} = D^\hermit \prod_{\substack{j=1\\ j\ne i}} \frac{M - \lambda_i\identityMatrix_{\symcal{V}}}{\lambda_i - \lambda_j} D.
    \end{equation}
    These projection operators are orthogonal, \(\projector{i}\projector{j} = \delta_{ij}\), and complete,
    \begin{equation}
        \sum_{i=1}^{k} \projector{i} = \identityMatrix_{\symcal{V}}.
    \end{equation}
    The dimension of the \(i\)th subspace is given by \(d_i = \tr(D \projector{i} D^\hermit) = \tr(\projector{i}D^\hermit D) =\tr(\projector{i})\).
    
    \subsection{Clebsch--Gordan Coefficients}
    Now consider the product
    \begin{equation}
        \begin{pmatrix}
            0\identityMatrix_{V_1} \\
            & \ddots \\
            && \identityMatrix_{V_i} \\
            &&& \ddots \\
            &&&& 0\identityMatrix_{V_k}
        \end{pmatrix}
        D
    \end{equation}
    which appears as part of the definition of the projector \(\projector{i}\).
    The matrix we get upon computing this product has non-zero entries only in a \(d_i \times d\) block.
    We call this block \(C_i\).
    These blocks are called \defineindex{Clebsch--Gordan coefficients}.
    The elements of this matrix are \((C_i)_\sigma^\alpha\), where \(\alpha = 1, \dotsc, d\) and \(\sigma = 1, \dotsc, d_i\).
    Here \(\alpha\) stands for all tensor indices associated with the \(d = n^{p + q}\) dimensional tensor space \(V^{\otimes p} \otimes \dual{V}^{\otimes q}\).
    This means we can replace the single index \(\alpha\) with \(d\) individual indices, \(\tensor{\mathstrut}{^\alpha} = \tensor*{\mathstrut}{^{b_p \dotso b_1}_{a_q\dotso a_1}}\), where \(a_j, b_j = 1, \dotsc, n\).
    
    In birdtracks we denote Clebsch--Gordan coefficients as
    \begin{equation}
        \tensor*{{(C_i)_{\sigma,}}}{^{b_p\dotso b_1}_{a_q\dotso a_1}} = 
        \tikzsetnextfilename{scalars-clebsch}
        \begin{tikzpicture}[baseline=(sigma.base)]
            \draw[wire arrow reversed=0.425] (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] (sigma) {\(\sigma\)} -- (0, 0) node [midway, above, font=\scriptsize] {\(i\)};
            \draw (0, 0) -- (30:1) -- (-30:1) coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (right |- 0, 0.4) -- ++ (1, 0) node [right, font=\scriptsize, xshift=-0.1cm] {\(b_1\)};
            \draw[wire arrow reversed=0.425] (right |- 0, 0.2) -- ++ (1, 0) node [right, font=\scriptsize, xshift=-0.1cm] {\(b_2\)};
            \draw[wire arrow=0.575] (right |- 0, -0.2) -- ++ (1, 0) node [right, font=\scriptsize, xshift=-0.1cm, yshift=-0.05cm] {\(a_{q-1}\)};
            \draw[wire arrow=0.575] (right |- 0, -0.4) -- ++ (1, 0) node [right, font=\scriptsize, xshift=-0.1cm, yshift=-0.05cm] {\(a_q\)};
            \node at ($(right |- 0, 0) + (0.5, 0)$) {\scriptsize\(\vdots\)};
        \end{tikzpicture}
        .
    \end{equation}
    This is a map \(V \to V_i\), where \(V_i\) is viewed as a subspace of \(V\), so we can treat it as having dimension \(d_i\) or dimension \(d\).
    The label \(i\) labels the subspace onto which we are projecting.
    We also have the conjugate mapping \(V_i \to \dual{V}\) which we get by instead considering the product
    \begin{equation}
        D^\hermit
        \begin{pmatrix}
            0\identityMatrix_{V_1} \\
            & \ddots \\
            && \identityMatrix_{V_i} \\
            &&& \ddots \\
            &&&& 0\identityMatrix_{V_k}
        \end{pmatrix}
        ,
    \end{equation}
    which again is non-zero only on a \(d \times d_i\) block, \(C^i\), whose components we denote by
    \begin{equation}
        {\tensor*{(C^i)}{^{a_1\dotso a_q}_{b_1 \dotso b_p}}}^{,\sigma} = 
        \tikzsetnextfilename{scalars-clebsch-conjguate}
        \begin{tikzpicture}[baseline=(sigma.base)]
            \draw (0, 0.5) -- (0, -0.5) coordinate (left) -- ++ (30:1) coordinate (right) -- cycle;
            \draw[wire arrow=0.575] (left |- 0, 0.4) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(b_1\)};
            \draw[wire arrow=0.575] (left |- 0, 0.2) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm] {\(b_2\)};
            \draw[wire arrow reversed=0.425] (left |- 0, -0.2) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm, yshift=-0.05cm] {\(a_{q-1}\)};
            \draw[wire arrow reversed=0.425] (left |- 0, -0.4) -- ++ (-1, 0) node [left, font=\scriptsize, xshift=0.1cm, yshift=-0.05cm] {\(a_q\)};
            \node at ($(left |- 0, 0) + (-0.5, 0)$) {\scriptsize\(\vdots\)};
            \draw[wire arrow reversed=0.425] (right) -- ++ (1, 0) node [midway, above, font=\scriptsize] {\(i\)} node [right, xshift=-0.1cm, font=\scriptsize] (sigma) {\(\sigma\)};
        \end{tikzpicture}
        .
    \end{equation}
    
    We can recover the projection operators from the Clebsch--Gordan coefficients:
    \begin{equation}
        \projector{i} = C^i C_i \qquad \text{(no sum on \(i\))}
    \end{equation}
    or in the diagrammatic notation
    \begin{equation}
        \tikzsetnextfilename{scalars-clebsch-square-to-projector}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw (0, 0.5) -- (0, -0.5) coordinate (left) -- ++ (30:1) coordinate (right) -- cycle;
            \draw[wire arrow=0.575] (left |- 0, 0.4) -- ++ (-1, 0);
            \draw[wire arrow=0.5775] (left |- 0, 0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.4) -- ++ (-1, 0);
            \node at ($(left |- 0, 0) + (-0.5, 0)$) {\scriptsize\(\vdots\)};
            \draw[wire arrow reversed=0.425] (right) -- ++ (1, 0) node [midway, above, font=\scriptsize] {\(i\)} coordinate (A);
            \draw (A) -- ++ (30:1) -- ++ (0, -1) coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (right |- 0, 0.4) -- ++ (1, 0);
            \draw[wire arrow reversed=0.425] (right |- 0, 0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.4) -- ++ (1, 0);
            \node at ($(right |- 0, 0) + (0.5, 0)$) {\scriptsize\(\vdots\)};
            \node (equal) at (4, 0) {\(=\)};
            \coordinate (left) at (5.27, 0);
            \coordinate (right) at (6.27, 0);
            \draw (left |- 0, -0.5) rectangle (right |- 0, 0.5) node [midway] {\(\projector{i}\)};
            \draw[wire arrow=0.575] (left |- 0, 0.4) -- ++ (-1, 0);
            \draw[wire arrow=0.5775] (left |- 0, 0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.4) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (right |- 0, 0.4) -- ++ (1, 0);
            \draw[wire arrow reversed=0.425] (right |- 0, 0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.4) -- ++ (1, 0);
            \node at ($(left |- 0, 0) + (-0.5, 0)$) {\scriptsize\(\vdots\)};
            \node at ($(right |- 0, 0) + (0.5, 0)$) {\scriptsize\(\vdots\)};
        \end{tikzpicture}
        .
    \end{equation}
    
    The completeness relation, \(\sum_i \projector{i} = \identity_{\symcal{V}}\), becomes \(\sum_i C^iC_i = \identity_{\symcal{V}}\), or in the diagrammatic notation
    \begin{equation}
        \sum_{i=1}^{k}
        \tikzsetnextfilename{scalars-completeness-of-clebsch}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw (0, 0.5) -- (0, -0.5) coordinate (left) -- ++ (30:1) coordinate (right) -- cycle;
            \draw[wire arrow=0.575] (left |- 0, 0.4) -- ++ (-1, 0);
            \draw[wire arrow=0.5775] (left |- 0, 0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.4) -- ++ (-1, 0);
            \node at ($(left |- 0, 0) + (-0.5, 0)$) {\scriptsize\(\vdots\)};
            \draw[wire arrow reversed=0.425] (right) -- ++ (1, 0) node [midway, above, font=\scriptsize] {\(i\)} coordinate (A);
            \draw (A) -- ++ (30:1) -- ++ (0, -1) coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (right |- 0, 0.4) -- ++ (1, 0);
            \draw[wire arrow reversed=0.425] (right |- 0, 0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.4) -- ++ (1, 0);
            \node at ($(right |- 0, 0) + (0.5, 0)$) {\scriptsize\(\vdots\)};
            \node (equal) at (4, 0) {\(=\)};
            \coordinate (left) at (5.27, 0);
            \coordinate (right) at (6.27, 0);
            \draw[wire arrow=0.575] (left |- 0, 0.4) -- ++ (-1, 0);
            \draw[wire arrow=0.5775] (left |- 0, 0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.2) -- ++ (-1, 0);
            \draw[wire arrow reversed=0.425] (left |- 0, -0.4) -- ++ (-1, 0);
            \node at ($(left |- 0, 0) + (-0.5, 0)$) {\scriptsize\(\vdots\)};
        \end{tikzpicture}
        .
    \end{equation}
    
    By construction the Clebsch--Gordan coefficients are orthogonal, in the sense that \(C_i C^j = \tensor{\delta}{_i^j}\identityMatrix_{\symcal{V}}\), where \(C_i\) are viewed as matrices acting on \(\symcal{V}\) sending anything outside of the \(V_i\) subspace to zero.
    In diagrammatic notation
    \begin{equation}\label{eqn:clebsch orthogonal}
        \tikzsetnextfilename{scalars-orthogonal-clebsch}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw (1.86, 0.5) -- ++ (0, -1) coordinate (left) -- ++ (30:1) coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (right) -- ++ (1, 0) node [midway, above, font=\scriptsize] {\(j\)};
            \draw[wire arrow=0.575] (0, 0) -- ++ (-1, 0) node [midway, above, font=\scriptsize] {\(i\)};
            \draw (0, 0) -- ++ (30:1) -- ++ (0, -1)  coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (right |- 0, 0.4) -- ++ (1, 0);
            \draw[wire arrow reversed=0.425] (right |- 0, 0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.2) -- ++ (1, 0);
            \draw[wire arrow=0.575] (right |- 0, -0.4) -- ++ (1, 0);
            \node at ($(right |- 0, 0) + (0.5, 0)$) {\scriptsize\(\vdots\)};
            \node (equal) at (4, 0) {\(=\)};
            \draw[wire arrow reversed=0.425] (4.27, 0) node [above, font=\scriptsize] {\(i\)} -- ++ (1, 0) node [above, font=\scriptsize] {\(j\)};
        \end{tikzpicture}
        .
    \end{equation}
    
    The traditional approach to representation theory is to compute the values of the Clebsch--Gordan coefficients and then use these in calculations, such as writing tensor products of representations as direct sums of irreducible representations.
    This simply becomes an exercise in looking up different components of the Clebsch--Gordan coefficients.
    Unfortunately the plethora of different notations and conventions for signs and normalisations of Clebsch--Gordans can make this quite a difficult task.
    We instead work with the projection operators, which allows us to avoid much of this tedious work.
    
    \subsection{Recoupling Relations}
    We now consider Clebsch--Gordan coefficients \(V_\mu \otimes V_\nu \to V_\lambda\), where each of these spaces is viewed as a subspace of some space \(\symcal{V}\).
    These Clebsch--Gordan coefficients can be drawn as
    \begin{equation}
        \tikzsetnextfilename{scalars-clebsch-2}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw (0, 0) -- (30:1) -- (-30:1) coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (0, 0) -- (-1, 0) node [midway, above, font=\scriptsize] {\(\lambda\)};
            \draw[wire arrow reversed=0.425] (right |- 0, 0.25) -- ++ (1, 0) node [midway, above, font=\scriptsize] {\(\mu\)};
            \draw[wire arrow reversed=0.425] (right |- 0, -0.25) -- ++ (1, 0) node [midway, below, font=\scriptsize] {\(\nu\)};
        \end{tikzpicture}
    \end{equation}
    and its Hermitian conjugate.
    
    Rather than work with the Clebsch--Gordan coefficients directly we work with 3-vertices defined by
    \begin{equation}
        \tikzsetnextfilename{scalars-3-vertex}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw (0, 0) -- (30:1) -- (-30:1) coordinate (right) -- cycle;
            \draw[wire arrow reversed=0.425] (0, 0) -- (-1, 0) node [midway, above, font=\scriptsize] {\(\lambda\)};
            \draw[wire arrow reversed=0.425] (right |- 0, 0.25) -- ++ (1, 0) node [midway, above, font=\scriptsize] {\(\mu\)};
            \draw[wire arrow reversed=0.425] (right |- 0, -0.25) -- ++ (1, 0) node [midway, below, font=\scriptsize] {\(\nu\)};
            \node (equal) at (2.4, -0.05) {\(\displaystyle {} = \frac{1}{\sqrt{a_\lambda}}\)};
            \draw[wire arrow reversed=0.3] (3, 0) -- ++ (0.75, 0) node [midway, above, font=\scriptsize] {\(\lambda\)};
            \fill (3.75, 0) circle [radius=0.05];
            \draw[wire arrow reversed=0.3, xshift=3.75cm] (45:0.75) -- (0, 0) node [midway, above, font=\scriptsize] {\(\mu\)};
            \draw[wire arrow reversed=0.3, xshift=3.75cm] (-45:0.75) -- (0, 0) node [midway, below, font=\scriptsize] {\(\nu\)};
        \end{tikzpicture}
        .
    \end{equation}
    The normalisation is defined by
    \begin{equation}
        a_{\lambda} = \frac{
            \tikzsetnextfilename{scalars-3j}
            \begin{tikzpicture}
                \draw[wire] (0, 0) circle [radius=0.3];
                \draw[wire arrow reversed=0.3] (-0.3, 0) -- (0.3, 0) node [midway, above, font=\tiny, yshift=-0.05cm] {\(\lambda\)};
                \draw[wire, postaction={decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}}] (0.05, 0.3) -- ++ (0.01, 0);
                \draw[wire, postaction={decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}}] (0.05, -0.3) -- ++ (0.01, 0);
                \node[font=\tiny] at (30:0.41) {\(\mu\)};
                \node[font=\tiny] at (-30:0.4) {\(\nu\)};
                \fill (0.3, 0) circle [radius = 0.05];
                \fill (-0.3, 0) circle [radius = 0.05];
            \end{tikzpicture}
        }{d_\lambda}.
    \end{equation}
    We call this diagram a \define{\(\symbf{3j}\) coefficient}\index{3j coefficient@\(3j\) coefficient}.
    This normalisation choice is such that
    \begin{equation}
        \tikzsetnextfilename{scalars-3-vertex-normalisation}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire] (0, 0) circle [radius=0.3];
            \draw[wire arrow reversed=0.3] (-1, 0) -- (-0.3, 0) node [midway, above, font=\tiny, yshift=-0.05cm] {\(\lambda\)};
            \draw[wire arrow reversed=0.3] (0.3, 0) -- (1, 0) node [midway, above, font=\tiny, yshift=-0.05cm] {\(\sigma\)};
            \draw[wire, postaction={decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}}] (0.05, 0.3) -- ++ (0.01, 0);
            \draw[wire, postaction={decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}}] (0.05, -0.3) -- ++ (0.01, 0);
            \node[font=\tiny] at (90:0.45) {\(\mu\)};
            \node[font=\tiny] at (-90:0.45) {\(\nu\)};
            \fill (0.3, 0) circle [radius = 0.05];
            \fill (-0.3, 0) circle [radius = 0.05];
            \node (equal) at (1.4, -0.05) {\({} = a_{\lambda}\)};
            \draw[wire arrow reversed=0.425] (1.9, 0) node [above, font=\scriptsize] {\(\lambda\)} -- ++ (1, 0) node [above, font=\scriptsize] {\(\sigma\)};
        \end{tikzpicture}
        .
    \end{equation}
    Notice that this is simply the orthogonality of the Clebsch--Gordan coefficients (\cref{eqn:clebsch orthogonal}) in terms of the 3-vertices.
    We do not fix the normalisation, \(a_\lambda\), in an attempt to be as general as possible.
    
    These \(3j\) coefficients are actually very common in physics, we just don't always call them \(3j\)s.
    If we work in \(\specialUnitary(2)\) in the fundamental representation taking \(a_\lambda = 1/2\) then these \(3j\)s are the Pauli matrices, \(\sigma_i\).
    If we work in \(\specialUnitary(2)\) (\(\specialUnitary(3)\)), take \(\lambda\) to be the adjoint representation, take \(\mu\) and \(\nu\) to be the fundamental representation, and take \(a_\lambda = 1/2\) then these \(3j\)s are the Pauli matrices, \(\sigma^i\) (Gell-Mann matrices \(\lambda^i\)) \cite[33]{cvitanovic}.
    If we work in \(\specialOrthogonal^{+}(1, 3)\), take \(\lambda\) to be the four dimensional vector representation, and take \(\mu\) and \(\nu\) to be the four dimensional spinor representation then these \(3j\)s are Dirac's gamma matrices, \(\gamma^\mu\) \cite{kennedy}.
    Compare this with the QED vertex,
    \begin{equation}
        \tikzsetnextfilename{scalars-qed-vertex}
        \begin{tikzpicture}[baseline=-0.05cm]
            \draw[photon] (-0.75, 0) node [left, font=\scriptsize] {\(\mu\)} -- (0, 0);
            \draw[electron=0.65] (0, 0) -- (45:0.75);
            \draw[electron=0.65] (-45:0.75) -- (0, 0);
        \end{tikzpicture}
        = ie\gamma^\mu
    \end{equation}
    which has two electrons (spinors) and a photon (vector) and is proportional to \(\gamma^\mu\).
    
    For simplicity we now drop arrows on our wires, they can be reinstated by picking one arrow and then ensuring that no vertex has two arrows pointing into it, similar to the interpretation of lines in a Feynman diagram as currents.
    In terms of 3-vertices the completeness relation is
    \begin{equation}
        \tikzsetnextfilename{scalars-completeness-with-3-vertices}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \node (equal) at (-1.5, -0.2) {\(\displaystyle {} = \sum_{\lambda} \frac{d_\lambda}{\threejnoarrow{\lambda}{\mu}{\nu}}\)};
            \draw[wire] (0, 0) -- (1, 0) node [midway, above, font=\scriptsize] {\(\lambda\)};
            \draw[wire] (0, 0) -- (135:0.75);
            \draw[wire] (0, 0) -- (-135:0.75);
            \draw[wire] (1, 0) -- ++ (45:0.75);
            \draw[wire] (1, 0) -- ++ (-45:0.75);
            \fill (0, 0) circle [radius=0.05];
            \fill (1, 0) circle [radius=0.05];
            \draw[wire] (-2.5, {0.75*sqrt(2)/2}) -- ++ (-1, 0) node [midway, below, font=\scriptsize] {\(\mu\)};
            \draw[wire] (-2.5, {-0.75*sqrt(2)/2}) -- ++ (-1, 0) node [midway, above, font=\scriptsize] {\(\nu\)};
        \end{tikzpicture}
        .
    \end{equation}
    This relation takes two unconnected lines and connects them.
    For this reason we call it the \defineindex{recoupling relation}.
    
    Now consider the diagram
    \begin{equation}
        \tikzsetnextfilename{scalars-t-channel}
        \begin{tikzpicture}[baseline=(current bounding box), font=\scriptsize]
            \draw[wire] (0, 0) -- (2, 0) node [pos=0.25, below, yshift=0.075cm] {\(\rho\)} node [pos=0.75, below, yshift=0.075cm] {\(\nu\)};
            \draw[wire] (0, 1) -- (2, 1) node [pos=0.25, above, yshift=-0.075cm] {\(\sigma\)} node [pos=0.75, above, yshift=-0.075cm] {\(\mu\)};
            \draw[wire] (1, 0) -- (1, 1) node [midway, right, xshift=-0.075cm] {\(\omega\)};
            \fill (1, 0) circle [radius=0.05];
            \fill (1, 1) circle [radius=0.05];
        \end{tikzpicture}
        .
    \end{equation}
    Using the recoupling relation twice, once on the two incoming wires and once on the two outgoing wires we get
    \begin{equation}
        \tikzsetnextfilename{scalars-recoupled-t-channel}
        \begin{tikzpicture}[baseline=(equal.base), font=\scriptsize]
            \draw[wire] (0.3, 0) -- (2.3, 0) node [pos=0.25, below, yshift=0.075cm] {\(\rho\)} node [pos=0.75, below, yshift=0.075cm] {\(\nu\)};
            \draw[wire] (0.3, 1) -- (2.3, 1) node [pos=0.25, above, yshift=-0.075cm] {\(\sigma\)} node [pos=0.75, above, yshift=-0.075cm] {\(\mu\)};
            \draw[wire] (1.3, 0) -- (1.3, 1) node [midway, right, xshift=-0.075cm] {\(\omega\)};
            \fill (1.3, 0) circle [radius=0.05];
            \fill (1.3, 1) circle [radius=0.05];
            \node (equal) at (2.5, 0.5) {\(=\)};
            \node[right] at (equal) {\(\displaystyle \sum_{\lambda, \lambda'} \frac{d_\lambda}{\mathstrut\smash{\raisebox{0.3cm}{{\threejnoarrow{\lambda}{\mkern-10mu\sigma}{\mkern-10mu\rho}}}}} \frac{d_{\lambda'}}{\mathstrut\smash{\raisebox{0.3cm}{\threejnoarrow{\lambda'}{\mkern-10mu\mu}{\mkern-10mu\nu}}}}\)};
            \draw[wire] (5.5, 0.5) -- ++ (1, 0) node [midway, above] {\(\lambda\)};
            \draw[wire] (5.5, 0.5) -- ++ (135:0.75) node [pos=0.3, above] {\(\sigma\)};
            \draw[wire] (5.5, 0.5) -- ++ (-135:0.75) node [pos=0.3, below] {\(\rho\)};
            \draw[wire] (6.5, 0.5) -- ++ (45:0.75) coordinate (A) node [pos=0.3, above] {\(\sigma\)};
            \draw[wire] (6.5, 0.5) -- ++ (-45:0.75) coordinate (B) node [pos=0.3, below] {\(\rho\)};
            \draw[wire] (A) -- (B) node [midway, right, xshift=-0.08cm] {\(\omega\)};
            \draw[wire] (A) -- ++ (-45:0.75) node [pos=0.7, above] {\(\mu\)};
            \draw[wire] (B) -- ++ (45:0.75) coordinate (C) node [pos=0.7, below] {\(\nu\)};
            \draw[wire] (C) -- ++ (1, 0) coordinate (D) node [pos=0.7, above] {\(\lambda\mathrlap{'}\)};
            \draw[wire] (D) -- ++ (45:0.75) node [pos=0.3, above] {\(\mu\)};
            \draw[wire] (D) -- ++ (-45:0.75) node [pos=0.3, below] {\(\nu\)};
        \end{tikzpicture}
        .
    \end{equation}
    We can further simplify this if we assume that \(V_\lambda\) and \(V_{\lambda'}\) correspond to irreducible representations.
    Notice that the middle of this diagram takes on the form
    \begin{equation}
        \tikzsetnextfilename{scalars-irrep-op}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[blob] (0, 0) circle [radius=0.5];
            \draw[wire] (0.5, 0) -- ++ (1, 0);
            \draw[wire] (-0.5, 0) -- ++ (-1, 0);
        \end{tikzpicture}
    \end{equation}
    where the two external wires are irreducible representations.
    This is an operator taking an irreducible subspace to another irreducible subspace.
    By virtue of being irreducible this means that these subspaces must actually be equal and this operator is proportional to the identity.
    That is
    \begin{equation}
        \tikzsetnextfilename{scalars-irrep-op-propto-identity}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[blob] (0, 0) circle [radius=0.5];
            \draw[wire] (0.5, 0) -- ++ (1, 0);
            \draw[wire] (-0.5, 0) -- ++ (-1, 0);
            \node at (1.8, -0.01) {\({} = \kappa\)};
            \draw[wire] (2.2, 0) -- ++ (1, 0);
        \end{tikzpicture}
    \end{equation}
    Taking the trace of this equation we get
    \begin{equation}
        \tikzsetnextfilename{scalars-trace-irrep-op}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[blob] (0, 0) circle [radius=0.5];
            \draw[wire] (0.5, 0) -- ++ (0.3, 0) arc (90:-90:0.3) -- ++ (-1.6, 0) arc (270:90:0.3) -- ++ (0.3, 0);
            \node at (1.5, -0.05) {\({} = \smash{\kappa}\)};
            \draw[wire] (2.4, 0) circle [radius=0.5];
            \node at (3.35, -0.05) {\({} = \smash{\kappa d}\)};
        \end{tikzpicture}
    \end{equation}
    where \(d\) is the dimension of the irreducible representation.
    Thus, we find that
    \begin{equation}
        \tikzsetnextfilename{scalars-irrep-op-in-terms-of-trace}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[blob] (0, 0) circle [radius=0.5];
            \draw[wire] (0.5, 0) -- ++ (1, 0);
            \draw[wire] (-0.5, 0) -- ++ (-1, 0);
            \node at (1.8, -0.01) {\(=\)};
            \node[right] at (2, 0) {\(\displaystyle \frac{
                    \begin{tikzpicture}
                        \draw[blob] (0, 0) circle [radius=0.3];
                        \draw[wire] (0.3, 0) arc (90:-90:0.2) -- ++ (-0.6, 0) arc (270:90:0.2);
                    \end{tikzpicture}
                }{d}\)};
            \draw[wire] (3.5, 0) -- ++ (1, 0);
        \end{tikzpicture}
        .
    \end{equation}
    Using this, and using the identity as the Kronecker delta to eliminate one of the sums, we get the result
    \begin{equation}\label{eqn:s and t channel relation}
        \tikzsetnextfilename{scalars-s-t-channel-relation}
        \begin{tikzpicture}[baseline=(equal.base), font=\scriptsize]
            \draw[wire] (0.3, 0) -- (2.3, 0) node [pos=0.25, below, yshift=0.075cm] {\(\rho\)} node [pos=0.75, below, yshift=0.075cm] {\(\nu\)};
            \draw[wire] (0.3, 1) -- (2.3, 1) node [pos=0.25, above, yshift=-0.075cm] {\(\sigma\)} node [pos=0.75, above, yshift=-0.075cm] {\(\mu\)};
            \draw[wire] (1.3, 0) -- (1.3, 1) node [midway, right, xshift=-0.075cm] {\(\omega\)};
            \fill (1.3, 0) circle [radius=0.05];
            \fill (1.3, 1) circle [radius=0.05];
            \node (equal) at (2.5, 0.5) {\(=\)};
            \node[right, yshift=-0.1cm] (sum) at (equal) {\(\displaystyle \sum_{\lambda, \lambda'} d_\lambda \)};
            \node[right, yshift=0.2cm, xshift=0.3cm] at (sum) {\(\displaystyle \frac{\sixjnoarrow{\mkern-13mu\lambda}{\sigma}{\mkern-15mu\mu}{\omega}{\nu}{\rho}}{\mathstrut\smash{\raisebox{0.3cm}{{\threej{\lambda}{\mkern-10mu\sigma}{\mkern-10mu\rho}}}}\smash{\raisebox{0.3cm}{\threej{\lambda'}{\mkern-10mu\mu}{\mkern-10mu\nu}}}}\)};
            \draw[wire] (6, 0.5) -- ++ (1, 0) node [midway, above] {\(\lambda\)};
            \draw[wire] (6, 0.5) -- ++ (135:0.75) node [pos=0.3, above] {\(\sigma\)};
            \draw[wire] (6, 0.5) -- ++ (-135:0.75) node [pos=0.3, below] {\(\rho\)};
            \draw[wire] (7, 0.5) -- ++ (45:0.75) coordinate (A) node [pos=0.3, above] {\(\rho\)};
            \draw[wire] (7, 0.5) -- ++ (-45:0.75) coordinate (B) node [pos=0.3, below] {\(\nu\)};
            \node at (4.6, -0.6) {};
        \end{tikzpicture}
        .
    \end{equation}
    In the language of Feynman diagrams this gives a relation between the \(s\)-channel and \(t\)-channel diagrams.
    
    We call the diagram
    \begin{equation}
        \tikzsetnextfilename{scalars-6j-coefficient}
        \sixjnoarrow{}{}{}{}{}{}
    \end{equation}
    appearing in this expression a \define{\(\symbf{6j}\) coefficient}\index{6j coefficient@\(6j\) coefficient}.
    
    \subsection{Reducing Scalars}
    Any group theoretical scalar quantity which can be written in terms of Clebsch--Gordan coefficients can be reduced to a sum of \(3j\) and \(6j\) coefficients by repeatedly applying the recoupling relations.
    To demonstrate this we show that any loop appearing in such a diagram can be shrunk to zero.
    Then given a scalar we can simplify it to a sum of \(3j\) and \(6j\) coefficients by shrinking the loops to zero and leaving behind only \(3j\) and \(6j\) coefficients, and factors such as \(d_\lambda\), which can be computed with \cref{eqn:dim of SU N rep}.
    
    Suppose we have a scalar diagram with the following subdiagram:
    \begin{equation}
        \tikzsetnextfilename{scalars-loop-subdiagram}
        \begin{tikzpicture}
            \foreach \angle/\name in {22.5/A, 67.5/B, 112.5/C, 157.5/D, 202.5/E, 247.5/F, 292.5/G, 337.5/H} {
                \coordinate (\name) at (\angle:0.75);
                \fill (\name) circle [radius=0.05];
                \draw[wire] (\name) -- (\angle:1.25);
            }
            \draw[wire] (A) -- (B) -- (C) -- (D) -- (E) -- (F) -- (G) -- (H) -- cycle;
        \end{tikzpicture}
        .
    \end{equation}
    Rewriting this slightly we can apply \cref{eqn:s and t channel relation} and we find that
    \begin{equation}
        \tikzsetnextfilename{scalars-loop-reduction}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[wire] (0, 0) coordinate (A) -- (0, 0.6) coordinate (B);
            \draw[wire] (0, 0) -- ++ (-0.6, 0);
            \draw[wire] (-0.6, 0) -- (0.6, 0) coordinate (C) -- ++ (-30:0.6) coordinate (D) -- ++ (30:0.6) coordinate (E) -- ++ (0, 0.6) coordinate (F) -- ++ (150:0.6) coordinate (G) -- ++ (210:0.6) coordinate (H) -- ++ (-1.2, 0);
            \foreach \name in {A, B, C, D, E, F, G, H} {
                \fill (\name) circle [radius=0.05];
            }
            \draw[wire] (C) -- ++ (0, -0.5);
            \draw[wire] (D) -- ++ (0, -0.5);
            \draw[wire] (E) -- ++ (-30:0.5);
            \draw[wire] (F) -- ++ (30:0.5);
            \draw[wire] (G) -- ++ (0, 0.5);
            \draw[wire] (H) -- ++ (0, 0.5);
            \node (equal) at (2.5, 0.3) {\(=\)};
            \node[right, yshift=-0.12cm, xshift=0.1cm] (sum) at (equal) {\(\displaystyle \sum_{\lambda} d_{\lambda}\)};
            \node[right, xshift=0.4cm] at (sum) {\(\displaystyle \frac{\hspace{0.2cm}{\sixjnoarrow[0.3]{}{}{}{}{}{}}}{\hspace{0.4cm}\mathclap{\threejnoarrow[0.2]{}{}{}} \hspace{0.6cm} \mathclap{\threejnoarrow[0.2]{}{}{}}}\)};
            \draw[wire] (6.5, 0) coordinate (C1) -- ++ (-30:0.6) coordinate (D1) -- ++ (30:0.6) coordinate (E1) -- ++ (0, 0.6) coordinate (F1) -- ++ (150:0.6) coordinate (G1) -- ++ (210:0.6) coordinate (H1);
            \draw[wire] (H1) -- ++ (-135:0.43) coordinate (I);
            \draw[wire] (C1) -- ++ (135:0.43);
            \draw[wire] (C1) -- ++ (-135:0.5);
            \draw[wire] (D1) -- ++ (0, -0.5);
            \draw[wire] (E1) -- ++ (-30:0.5);
            \draw[wire] (F1) -- ++ (30:0.5);
            \draw[wire] (G1) -- ++ (0, 0.5);
            \draw[wire] (H1) -- ++ (135:0.5);
            \draw[wire] (I) -- ++ (-0.6, 0) coordinate (J);
            \draw[wire] (J) -- ++ (135:0.6);
            \draw[wire] (J) -- ++ (-135:0.6);
            \foreach \name in {C1, D1, E1, F1, G1, H1, I, J} {
                \fill (\name) circle [radius=0.05];
            }
        \end{tikzpicture}
        .
    \end{equation}
    We have successfully reduced the size of the loop by one Clebsch--Gordan coefficient.
    If we repeat this process with the next edge in the loop we will get more \(3j\)s and \(6j\)s, and we will again reduce the size of the loop by one.
    Continually applying this we will be left with one long chain, which in the full diagram is part of some other loop.
    We can then contract that loop, and any other loop, leaving us with just \(3j\)s, \(6j\)s, and dimensions.
    
    \subsection{Computing \texorpdfstring{\(3j\)s and \(6j\)s}{3js and 6js}}
    All we need to compute a scalar is to compute the \(3j\) and \(6j\) coefficients.
    This can be done using Young projectors, the representations of which we can compute using the method laid out in \cref{sec:computing representations of Sn}.
    First, consider an expression of the form
    \begin{equation}
        \tikzsetnextfilename{scalars-permutation-projector}
        \begin{tikzpicture}[baseline=(current bounding box)]
            \draw[wire] (-1, -0.5) -- (0, -0.5);
            \draw[wire] (-1, 0.5) -- (0, 0.5);
            \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\sigma\)};
            \node at (-0.5, 0) {\(\vdots\)};
            \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
            \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
            \node at (1, 0) {\(\vdots\)};
            \draw (1.5, -0.75) rectangle (2, 0.75) node [midway] {\(\projector{Y}\)};
            \draw[wire] (2, 0.5) -- (3, 0.5);
            \draw[wire] (2, -0.5) -- (3, -0.5);
            \node at (2.5, 0) {\(\vdots\)};
        \end{tikzpicture}
    \end{equation}
    where \(\sigma \in \symmetricGroup\) is a permutation and \(\projector{Y}\) is the Young projector associated with the Young diagram \(Y\).
    Taking the trace of this we get
    \begin{equation}
        \tikzsetnextfilename{scalars-permutation-projector-trace}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire] (0, -0.5) -- ++ (-0.3, 0) arc (90:270:0.2) -- ++ (2.6, 0) arc (-90:90:0.2) -- ++ (-0.3, 0);
            \draw[wire] (0, 0.5) -- ++ (-0.3, 0) arc (270:90:0.2) -- ++ (2.6, 0) arc (90:-90:0.2) -- ++ (-0.3, 0);
            \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\sigma\)};
            \node at (-0.2, 0) {\(\vdots\)};
            \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
            \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
            \node at (1, 0) {\(\vdots\)};
            \draw (1.5, -0.75) rectangle (2, 0.75) node [midway] {\(\projector{Y}\)};
            \node at (2.2, 0) {\(\vdots\)};
            \node (equal) at (3, 0) {\(=\)};
            \begin{scope}[xshift=4cm]
                \draw[wire] (0, -0.5) -- ++ (-0.3, 0) arc (90:270:0.2) -- ++ (4.1, 0) arc (-90:90:0.2) -- ++ (-0.3, 0);
                \draw[wire] (0, 0.5) -- ++ (-0.3, 0) arc (270:90:0.2) -- ++ (4.1, 0) arc (90:-90:0.2) -- ++ (-0.3, 0);
                \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\sigma\)};
                \node at (-0.2, 0) {\(\vdots\)};
                \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
                \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
                \node at (1, 0) {\(\vdots\)};
                \draw (1.5, -0.75) rectangle (2, 0.75) node [midway] {\(\projector{Y}\)};
                \node at (2.5, 0) {\(\vdots\)};
                \draw[wire] (2, 0.5) -- (3, 0.5);
                \draw[wire] (2, -0.5) -- (3, -0.5);
                \draw (3, -0.75) rectangle (3.5, 0.75) node [midway] {\(\projector{Y}\)};
                \node at (3.7, 0) {\(\vdots\)};
            \end{scope}
        \end{tikzpicture}
    \end{equation}
    where we've used the idempotency of the projectors, \(\projector{Y}\projector{Y} = \projector{Y}\).
    Since only connectivity matters in these diagrams we can move one of the projectors around to the front of this expression:
    \begin{equation}
        \tikzsetnextfilename{scalars-permutation-projector-sandwich}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire] (0, -0.5) -- ++ (-0.3, 0) arc (90:270:0.2) -- ++ (2.6, 0) arc (-90:90:0.2) -- ++ (-0.3, 0);
            \draw[wire] (0, 0.5) -- ++ (-0.3, 0) arc (270:90:0.2) -- ++ (2.6, 0) arc (90:-90:0.2) -- ++ (-0.3, 0);
            \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\sigma\)};
            \node at (-0.2, 0) {\(\vdots\)};
            \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
            \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
            \node at (1, 0) {\(\vdots\)};
            \draw (1.5, -0.75) rectangle (2, 0.75) node [midway] {\(\projector{Y}\)};
            \node at (2.2, 0) {\(\vdots\)};
            \node (equal) at (3, 0) {\(=\)};
            \begin{scope}[xshift=4cm]
                \draw[wire] (0, -0.5) -- ++ (-0.3, 0) arc (90:270:0.2) -- ++ (4.1, 0) arc (-90:90:0.2) -- ++ (-0.3, 0);
                \draw[wire] (0, 0.5) -- ++ (-0.3, 0) arc (270:90:0.2) -- ++ (4.1, 0) arc (90:-90:0.2) -- ++ (-0.3, 0);
                \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\projector{Y}\)};
                \node at (-0.2, 0) {\(\vdots\)};
                \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
                \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
                \node at (1, 0) {\(\vdots\)};
                \draw (1.5, -0.75) rectangle (2, 0.75) node [midway] {\(\sigma\)};
                \node at (2.5, 0) {\(\vdots\)};
                \draw[wire] (2, 0.5) -- (3, 0.5);
                \draw[wire] (2, -0.5) -- (3, -0.5);
                \draw (3, -0.75) rectangle (3.5, 0.75) node [midway] {\(\projector{Y}\)};
                \node at (3.7, 0) {\(\vdots\)};
            \end{scope}
        \end{tikzpicture}
        .
    \end{equation}
    There is only one way, up to an overall sign, to connect the symmetrisers and antisymmetrisers in a Young projector and get a non-zero result.
    This means that any Young projector sandwiching a permutation the result is proportional to the Young projector with the constant of proportionality being \(1\), \(-1\), or \(0\), depending on the permutation.
    Thus,
    \begin{equation}\label{eqn:projector sandwich proportional}
        \tikzsetnextfilename{scalars-projector-permutation-sandwich-proportional}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire] (0, -0.5) -- ++ (-1, 0);
            \draw[wire] (0, 0.5) -- ++ (-1, 0);
            \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\projector{Y}\)};
            \node at (-0.5, 0) {\(\vdots\)};
            \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
            \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
            \node at (1, 0) {\(\vdots\)};
            \draw (1.5, -0.75) rectangle (2, 0.75) node [midway] {\(\sigma\)};
            \node at (2.5, 0) {\(\vdots\)};
            \draw[wire] (2, 0.5) -- (3, 0.5);
            \draw[wire] (2, -0.5) -- (3, -0.5);
            \draw (3, -0.75) rectangle (3.5, 0.75) node [midway] {\(\projector{Y}\)};
            \draw[wire] (3.5, -0.5) -- ++ (1, 0);
            \draw[wire] (3.5, 0.5) -- ++ (1, 0);
            \node at (4, 0) {\(\vdots\)};
            \node (equal) at (4.9, 0) {\(=\)};
            \node[right, xshift=0.2cm] at (equal) {\(m_\sigma\)};
            \begin{scope}[xshift=6.7cm]
                \draw[wire] (0, -0.5) -- ++ (-1, 0);
                \draw[wire] (0, 0.5) -- ++ (-1, 0);
                \draw (0, -0.75) rectangle (0.5, 0.75) node [midway] {\(\projector{Y}\)};
                \node at (-0.5, 0) {\(\vdots\)};
                \draw[wire] (0.5, 0.5) -- (1.5, 0.5);
                \draw[wire] (0.5, -0.5) -- (1.5, -0.5);
                \node at (1, 0) {\(\vdots\)};
            \end{scope}
        \end{tikzpicture}
    \end{equation}
    where \(m_\sigma = 0, \pm 1\) depends only on the permutation \(\sigma\) and the Young projector \(\projector{Y}\).
    This means that we can compute traces like this working in \(\symmetricGroup\) and without reference to \(\specialUnitary(N)\).
    
    In terms of Young projectors the 3-vertex is
    \begin{equation}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire arrow=0.575] (135:1) -- (0, 0) node [midway, above] {\(X\)};
            \draw[wire arrow=0.575] (-135:1) -- (0, 0) node [midway, below] {\(Z\)};
            \draw[wire arrow=0.575] (0, 0) -- (1, 0) node [midway, above] {\(Y\)};
            \fill (0, 0) circle [radius=0.05];
            \node (equal) at (1.3, 0) {\(=\)};
            \draw[wire arrow=0.7] (2.1, 0.5) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (2.1, 0.2) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (2.1, -0.2) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (2.1, -0.5) -- ++ (0.5, 0);
            \draw[thick, decorate, decoration={calligraphic brace}] (2, 0.05) -- (2, 0.55) node [midway, left, font=\scriptsize] {\(k_X\)};
            \draw[thick, decorate, decoration={calligraphic brace}] (2, -0.55) -- (2, -0.05) node [midway, left, font=\scriptsize] {\(k_Z\)};
            \draw (2.6, 0.1) rectangle (3.1, 0.6) node [midway] {\(\projector{X}\)};
            \draw (2.6, -0.6) rectangle (3.1, -0.1) node [midway] {\(\projector{Z}\)};
            \draw[wire arrow=0.7] (3.1, 0.5) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (3.1, 0.2) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (3.1, -0.2) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (3.1, -0.5) -- ++ (0.5, 0);
            \draw (3.6, -0.6) rectangle (4.1, 0.6) node [midway] {\(\projector{Y}\)};
            \draw[wire arrow=0.7] (4.1, 0.5) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (4.1, 0.2) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (4.1, -0.2) -- ++ (0.5, 0);
            \draw[wire arrow=0.7] (4.1, -0.5) -- ++ (0.5, 0);
            \draw[thick, decorate, decoration={calligraphic brace, mirror}] (4.7, -0.55) -- (4.7, 0.55) node [midway, right, font=\scriptsize] {\(k_Y\)};
        \end{tikzpicture}
        .
    \end{equation}
    Here \(\projector{Y}\) are Young projectors associated with \(k_Y\) box Young diagrams, and hence with \(k_Y\) wires.
    The Young projectors \(\projector{X}\) and \(\projector{Z}\), and their combination, \(\projector{X} \otimes \projector{Z}\) which appears here, are just elements of the group algebra \(\complex[\symmetricGroup[k_Y]]\).
    The trace of the three vertex is the \(3j\) coefficient
    \begin{equation}
        \tikzsetnextfilename{scalars-3j-in-terms-of-Young-projectors}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire] (0.35, 0) circle [radius=0.6];
            \draw[wire arrow=0.6] (-0.25, 0) -- (0.95, 0) node [midway, above, font=\scriptsize] {\(Y\)};
            \fill (-0.25, 0) circle [radius=0.05];
            \fill (0.95, 0) circle [radius=0.05];
            \draw[thick, decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}] (0.33, 0.6) -- ++ (-0.01, 0) node [above, font=\scriptsize] {\(\mkern10muX\)};
            \draw[thick, decorate, decoration={markings, mark=at position 1 with \arrow{stealth}}] (0.33, -0.6) -- ++ (-0.01, 0) node [below, font=\scriptsize] {\(\mkern10muZ\)};
            \node (equal) at (1.3, 0) {\(=\)};
            \begin{scope}[xshift=-0.3cm]
                \draw[wire arrow=0.53] (2.6, 0.5) -- ++ (-0.3, 0) arc (270:90:0.1) -- ++ (2.1, 0) arc (90:-90:0.1) -- ++ (-0.3, 0);
                \draw[wire arrow=0.52] (2.6, 0.2) -- ++ (-0.3, 0) arc (270:90:0.4) -- ++ (2.1, 0) arc (90:-90:0.4) -- ++ (-0.3, 0);
                \draw[wire arrow=0.53] (2.6, -0.5) -- ++ (-0.3, 0) arc (90:270:0.1) -- ++ (2.1, 0) arc (-90:90:0.1) -- ++ (-0.3, 0);
                \draw[wire arrow=0.52] (2.6, -0.2) -- ++ (-0.3, 0) arc (90:270:0.4) -- ++ (2.1, 0) arc (-90:90:0.4) -- ++ (-0.3, 0);
                \draw (2.6, 0.1) rectangle (3.1, 0.6) node [midway] {\(\projector{X}\)};
                \draw (2.6, -0.6) rectangle (3.1, -0.1) node [midway] {\(\projector{Z}\)};
                \draw[wire arrow=0.7] (3.1, 0.5) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (3.1, 0.2) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (3.1, -0.2) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (3.1, -0.5) -- ++ (0.5, 0);
                \draw (3.6, -0.6) rectangle (4.1, 0.6) node [midway] {\(\projector{Y}\)};
            \end{scope}
            \node at (3, 1.1) {};
            \node at (3, -1.1) {};
        \end{tikzpicture}
        .
    \end{equation}
    This means that we can use the result \cref{eqn:projector sandwich proportional} to compute this by computing \(\projector{Y} (\projector{X} \otimes \projector{Z}) \projector{Y}\) and comparing to \(\projector{Y}\) to compute the constant of proportionality.
    
    Similarly, the \(6j\) coefficient is given by
    \begin{equation}
        \tikzsetnextfilename{scalars-6j-in-terms-of-Young-projectors}
        \begin{tikzpicture}[baseline=(equal.base)]
            \draw[wire] (0.35, 0) circle [radius=0.6];
            \begin{scope}[xshift=0.35cm, font=\scriptsize]
                \draw[wire arrow=0.65] (-30:0.6) -- (0, 0) node [pos=0.6, below] {\(V\)};
                \draw[wire arrow=0.65] (0, 0) -- (210:0.6) node [pos=0.6, above] {\(Z\)};
                \draw[wire arrow=0.65] (0, 0.6) -- (0, 0) node [pos=0.6, right, xshift=-0.05cm] {\(W\)};
                \fill (0, 0) circle [radius=0.05];
                \fill (0, 0.6) circle [radius=0.05];
                \fill (210:0.6) circle [radius=0.05];
                \fill (-30:0.6) circle [radius=0.05];
                \node at (30:0.75) {\(U\)};
                \node at (150:0.75) {\(X\)};
                \node at (270:0.75) {\(Y\)};
            \end{scope}
            \node (equal) at (1.5, 0) {\(=\)};
            \begin{scope}[xshift=2.5cm, yshift=-1.05cm, font=\small]
                \draw (0, -0.1) rectangle (0.5, 1.4) node [midway] {\(\projector{U}\)};
                \draw (1, -0.1) rectangle (1.5, 0.6) node [midway] {\(\projector{X}\)};
                \draw (1, 0.7) rectangle (1.5, 1.4) node [midway] {\(\projector{W}\)};
                \draw (1, 1.5) rectangle (1.5, 2.2) node [midway] {\(\projector{V}\)};
                \draw (2, 0.7) rectangle (2.5, 2.2) node [midway] {\(\projector{Z}\)};
                \draw (3, -0.1) rectangle (3.5, 2.2) node [midway] {\(\projector{Y}\)};
                \draw[wire arrow=0.7] (0.5, 0) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (0.5, 0.5) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (0.5, 0.8) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (0.5, 1.3) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (1.5, 0.8) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (1.5, 1.3) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (1.5, 1.6) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (1.5, 2.1) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (2.5, 0.8) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (2.5, 1.3) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (2.5, 1.6) -- ++ (0.5, 0);
                \draw[wire arrow=0.7] (2.5, 2.1) -- ++ (0.5, 0);
                \draw[wire arrow=0.55] (1.5, 0) -- ++ (1.5, 0);
                \draw[wire arrow=0.55] (1.5, 0.5) -- ++ (1.5, 0);
                \draw[wire arrow=0.52] (1, 2.1) arc (270:90:0.1) -- ++ (2.5, 0) arc (90:-90:0.1);
                \draw[wire arrow=0.513] (1, 1.6) arc (270:90:0.4) -- ++ (2.5, 0) arc (90:-90:0.4);
                \draw[wire arrow=0.577] (0, 1.3) arc (270:90:0.6) -- ++ (3.5, 0) arc (90:-90:0.6);
                \draw[wire arrow=0.64] (0, 0) arc (90:270:0.1) -- ++ (3.5, 0) arc (-90:90:0.1);
                \draw[wire arrow=0.595] (0, 0.5) arc (90:270:0.4) -- ++ (3.5, 0) arc (-90:90:0.4);
                \draw[wire arrow=0.58] (0, 0.8) arc (90:270:0.6) -- ++ (3.5, 0) arc (-90:90:0.6);
                \node[red] at (2.2, 2.6) {};
                \node[red] at (2.2, -0.5) {};
            \end{scope}
        \end{tikzpicture}
    \end{equation}
    which can also be computed by computing
    \begin{equation}
        \projector{Y} (\identityMatrix_{V} \otimes \projector{U})(\projector{V} \otimes \projector{W} \otimes \projector{X}) (\projector{Z} \otimes \identityMatrix_{X}) \projector{Y},
    \end{equation}
    where \(\identityMatrix_V\) and \(\identityMatrix_X\) are the identities on the subspaces which \(\projector{V}\) and \(\projector{X}\) project onto, and comparing this result with \(\projector{Y}\) to find the constant of proportionality.
    
    \section{Conclusion and Further Work}
    We started with \enquote{a tensor is something which transforms like a tensor}.
    This motivated the study of symmetry, captured by the notion of a group, and applied to tensors through a representation.
    We then introduced birdtracks as a notation for computing both tensors and permutations.
    
    The need to classify the symmetries of mixed tensors, such as the Riemann tensor, \(R_{\mu\nu\rho\sigma}\), lead to the introduction of Young diagrams to label these symmetries.
    The reverse question, of constructing tensors with a given symmetry, motivated the construction of Young projectors.
    We then saw that a particular basis of these, formed from standard tableaux, could be used to reduce the number of projectors we needed to calculate, as we could use the Garnir relations to write arbitrary tableaux in this basis.
    This is all happening at the level of the group algebra, \(\complex[G]\).
    We then saw how using Young diagrams we can label and compute irreducible representations of the symmetric group.
    This allows us to perform calculations on the level of a matrix algebra.
    
    Finally, we looked at tensors under \(\specialUnitary(N)\), which are prevalent in quantum field theory.
    We focused on scalars and we saw that any scalar can be reduced to a sum of products of scalars called \(3j\)s and \(6j\)s, which can in turn be computed using only the symmetric group and Young projectors.
    Essentially turning complicated \(\specialUnitary(N)\) calculations into an exercise in manipulating diagrams and then computing constants of proportionality between two different diagrams.
    
    There are many unanswered questions.
    We introduced Hermitian Young projectors, but didn't study them much.
    The hope is that these Hermitian Young projectors make certain calculations simpler, such as computing the \(3j\)s and \(6j\)s by making it immediately obvious how we can connect up the Young projectors in such a way that the result doesn't vanish.
    
    Another obvious question is if it is possible to generalise this work to other groups.
    In particular can it be generalised to \(\specialOrthogonal(N)\)?
    If so then these methods could be applied to classical mechanics and relativity, which involves extensive study of \(\specialOrthogonal^+(1, 3)\).
    
    On the computation side it would also be beneficial to write an algorithm which performs the graph manipulation required to simplify a given scalar diagram into a sum of \(3j\)s and \(6j\)s.
    The code for computing \(3j\)s and \(6j\)s is also not fully automated, it is sometimes necessary to manually insert a permutation between Young projectors to get a non-zero result.
    
    % TODO:
    % Actually computing 3js and 6js using traces of products of Young projectors
    
    % TODO: Talk about difference between Young projectors as related to Sn and SU(N) irreps
    % TODO: Talk about 3j and 6js and how every diagram can be reduced to them
    
    % TODO: Citations
    % TODO: Conclusion
    % TODO: Abstract
    % TODO: Personal statement
    
    
    \printbibliography
    % Appdendix
    \appendixpage
    \begin{appendices}
        \chapter{Linear Algebra}\label{sec:linear algebra}
        We assume the reader is familiar with basic linear algebra, specifically working with vectors and matrices.
        We will make use of certain concepts, such as direct sums and dual spaces, which are less common in physics, so we shall define them here.
        
        \section{Vector Spaces}
        Recall that a \defineindex{vector space} is a set, \(V\), along with a field of scalars, \(\field\), equipped with the operations of vector addition \(+ \colon V \times V \to V\), and scalar multiplication, \(\field \times V \to V\), such that
        \begin{itemize}
            \item \((V, +)\) is an Abelian group,
            \item scalar multiplication distributes over vector addition: \(z(v + u) = zv + zv\) for all \(z \in \field\) and \(u, v \in V\),
            \item scalar multiplication distributes over field addition: \((z + w)v = zv + wv\) for all \(z, w \in \field\) and \(v \in V\),
            \item \(1v = v\) for all \(v \in V\) where \(1 \in \field\) is the multiplicative identity,
            \item scalar multiplication and field multiplication are compatible, \(z(wv) = (zw)v\) for all \(z, w \in \field\) and \(v \in V\).
        \end{itemize}
        
        Given vector spaces \(V\) and \(W\) over the field \(\field\) a \defineindex{linear map} is a function \(\varphi \colon V \to W\) such that
        \begin{equation}
            \varphi(zv + u) = z\varphi(v) + \varphi(u)
        \end{equation}
        for all \(z\in \field\) and \(v, u \in V\).
        
        Given a vector space, \(V\), over the field \(\field\) we can form another vector space, \(\dual{V}\), also over \(\field\) called the \defineindex{dual space}, whose elements are linear maps \(V \to \field\), where \(\field\) is viewed as a one dimensional vector space over itself.
        Vector addition in \(\dual{V}\) is defined pointwise, so given linear maps \(\varphi, \psi \in \dual{V}\) their sum is the linear map \(\varphi + \psi \in \dual{V}\) defined by \((\varphi + \psi)(v) = \varphi(v) + \psi(v)\).
        Similarly, scalar multiplication in \(\dual{V}\) is defined such that given \(z \varphi \in \dual{V}\) and \(z \in \field\) we have \(z\varphi \in \dual{V}\) defined by \((z\varphi)(v) = z[\varphi(v)]\).
        
        \section{Tensor Products}
        Given two vector spaces \(V\) and \(W\) over \(\field\) we can form a new vector space, also over \(\field\), called their \defineindex{tensor product}, \(V \otimes W\).
        The simplest definition of the tensor product is basis dependent.
        Given bases \(\{e_i\}\) and \(\{d_j\}\) for \(V\) and \(W\) respectively \(V \otimes W\) is the span, that is all linear combinations, of \(\{e_i \otimes d_j\}\), where \(e_i \otimes d_j\) is the tensor product of the basis vectors \(e_i\) and \(d_j\).
        Notice that \(\dim(V \otimes W) = \dim(V) \dim(W)\).
        
        An arbitrary vector \(x \in V \otimes W\), then takes the form
        \begin{equation}
            x^{ij}e_i \otimes d_j,
        \end{equation}
        with the summation convention in effect.
        The components of this vector are the numbers \(x^{ij}\).
        
        The tensor product of \(v = v^ie_i \in V\) and \(w = w^jd_j \in W\) their tensor product is the vector \(v \otimes w = v^id^j e_i \otimes d_j\).
        That is, the vector with components \(v^iw^j\).
        So in index notation the tensor product is simply given by putting the vectors, or more generally tensors, next to each other with distinct indices.
        
        \section{Direct Sum}
        Given two vector spaces \(V\) and \(W\) over \(\field\) we can form a new vector space, also over \(\field\), called their \defineindex{direct sum}, \(V \oplus W\).
        The vectors here are the elements of the Cartesian product \(V \times W\), so take the form \((v, w)\) with \(v \in V\) and \(w \in W\).
        Vector addition is defined by \((v, w) + (v', w') = (v + v', w + w')\) for \(v, v' \in V\) and \(w, w' \in W\).
        Scalar addition is defined by \(z(v, w) = (zv, zw)\) for \(z \in \field\), \(v \in V\) and \(w \in W\).
        Notice that \(\dim(V \oplus W) = \dim(V) + \dim(W)\).
        
        Given a vector space \(V\) with subspace \(W\) we can identify a second subspace \(W^{\perp}\) which is such that \(V = W \oplus W^{\perp}\).
        
        \section{Algebra}\label{sec:algebras}
        An \defineindex{algebra}, \(A\), over \(\field\) is a vector space over \(\field\) with an additional product \(A \times A \to A\) allowing us to multiply two vectors.
        This product must be compatible with scalar multiplication and vector addition, leading to the following constraints:
        \begin{itemize}
            \item right distributivity: \(x(y + z) = xy + xz\) for all \(x, y, z \in A\),
            \item left distributivity: \((x + y)z = xz + yz\) for all \(x, y, z \in A\),
            \item compatability with scalars: \((ax)(by) = (ab)(xy)\) for all \(a, b \in \field\) and \(x, y \in A\).
        \end{itemize}
        
        An algebra homomorphism of algebras \(A\) and \(B\) over \(\field\) is a linear map \(f \colon A \to B\) which respects the algebra product: \(f(xy) = f(x)f(y)\) for all \(x, y \in A\).
        
        We are interested in two cases of algebras.
        First, the group algebra \(\complex[G]\), which is an associative algebra, the algebra product is associative, \(x(yz) = (xy)z\) for all \(x, y, z \in \complex[G]\).
        Associative algebras are familiar, for example \(\generalLinear(\field, n)\) is an associative algebra with vector addition, scalar multiplication, and vector multiplication being matrix addition, scalar multiplication of a matrix, and matrix multiplication respectively.
        Second, we are interested in Lie algebras, which are non-associative algebras.
        While non-associative products in general are less familiar we do see them in the form of the commutator, \(\commutator{-}{-}\), which makes \(\generalLinear(\field, n)\) into a Lie algebra.
        
        \chapter{Technicalities}
        There are many technicalities which are worth mentioning but would detract from the body of the report.
        These have been relegated to this appendix.
        
        \section{Multiple Definitions of Tensors}\label{sec:technicalities tensor defs}
        There are multiple, slightly different, definitions of tensors used across various fields of mathematics and science.
        A computer scientist might define a tensor to be a multi-dimensional array, so a rank 0 tensor is a number, a rank 1 tensor is a list, a rank 2 tensor is a matrix, and so on.
        This is fine, so long as we are only interested in working in one basis.
        
        The physics definition of a tensor, the one which we shall introduce shortly, does indeed take a tensor to be a collection of numbers, \(\tensor{T}{^{a_1\dotso a_q}_{b_1\dotso b_p}}\), but these numbers must also must follow a transformation law for how these numbers change under a transformation.
        Exactly what this law is depends on what sort of transformations we consider, and so this leads to the famously unhelpful \enquote{a tensor is something which transforms like a tensor}.
        
        A mathematician would define a tensor in one of two ways.
        To do so they start with a vector space, \(V\), over some field, \(\field\), then define the dual space, \(V^*\), which is the vector space formed from all linear functions \(V \to \field\), with addition and scalar multiplication defined pointwise.
        So, given \(\varphi, \psi \in V\) and \(z \in \field\) we have \((\varphi + \psi)(v) = \varphi(v) + \psi(v)\) and \((z\varphi)(v) = z[\varphi(v)]\) for all \(v \in V\).
        
        The first mathematician definition is then as follows.
        A tensor is a multilinear mapping \(T \colon V\ \times \dotsm V \times V^* \times \dotsb \times V^* \to \field\), where we have \(p\) copies of \(V\) and \(q\) copies of \(V^*\).
        In this case the physicists definition is that \(\tensor{T}{^{a_1 \dotso a_q}_{b_1 \dotso b_p}}\) corresponds to a tensor field, a function assigning a tensor to every point in spacetime in a basis independent way, evaluated on some set of basis vectors \(\{\ve{i}\}\) and dual basis covectors \(\{\dualve{j}\}\), so that
        \begin{equation}
            \tensor{T}{^{a_1 \dotso a_q}_{b_1 \dotso b_p}} = T(\ve{a_1}, \dotsc, \ve{a_q}, \dualve{b_1}, \dotsc, \dualve{b_p})
        \end{equation}
        
        Alternatively, a mathematician may first define the tensor product \(V \otimes W\), of two vector spaces, \(V\) and \(W\).
        Then a tensor is simply a vector in such a vector space.
        In particular one can identify the multilinear map definition above with a vector \(T \in V \otimes \dotsb \otimes V \otimes V^* \otimes \dotsm V^*\), again with \(p\) copies of \(V\) and \(q^*\) copies of \(V^*\).
        Then the physicists definition of a tensor are simply the components of this vector.
        This is the same definition we give in \cref{def:tensor}, although we then immediately switch to discussing the components.
        
        The relation between the two mathematician's definitions is due to the tensor-hom adjunction which says that there a canonical bijective mapping between tensor products and linear maps.
        
        \chapter{Garnir Relations Example}\label{app:garnir example}
        \section{Recursive Application}
        Consider the Young tableau
        \begin{equation}
            Y = \ytableaushort{14,35,2}.
        \end{equation}
        The rows are already sorted.
        The problem strip starts with the 3:
        \begin{equation}
            \begin{ytableau}
                1 & 4\\
                *(light highlight) 3 & *(light highlight) 5\\
                *(light highlight) 2
            \end{ytableau}
        \end{equation}
        The box numbers are
        \begin{equation}
            \ytableaushort{12,34,5},
        \end{equation}
        so the boxes in the strip are numbers 3, 4, and 5.
        We need to consider the permutations \(\cycle{3,5}\) and \(\cycle{4,5}\), giving
        \begin{equation}
            \cycle{3,5} \action Y = \ytableaushort{14,25,3}, \qqand \cycle{4,5} \action Y = \ytableaushort{14,32,5}.
        \end{equation}
        Sorting the rows we get the tableaux
        \begin{equation}
            \ytableaushort{14,25,3}, \qqand \ytableaushort{14,23,5}.
        \end{equation}
        Thus
        \begin{equation}
            Y = \ytableaushort{14,35,2} = -\ytableaushort{14,25,3} - \ytableaushort{14,23,5}.
        \end{equation}
        The first tableau is standard, but the second isn't, we have a four above a 3.
        So, we need to recursively apply the Garnir relations.
        
        Starting again with
        \begin{equation}
            \tilde{Y} = \ytableaushort{14,23,5}
        \end{equation}
        we identify the problem strip:
        \begin{equation}
            \begin{ytableau}
                1 & *(light highlight) 4\\
                *(light highlight) 2 & *(light highlight) 3\\
                5
            \end{ytableau}
        \end{equation}
        Notice that the problem point has moved right compared to the starting tableau \(Y\).
        We need to consider the permutations \(\cycle{2,3}\) and \(\cycle{2,4}\).
        Applying these gives
        \begin{equation}
            \cycle{2,3} \action \tilde{Y} = \ytableaushort{12,43,5}, \qqand \cycle{2,4} \action \tilde{Y} = \ytableaushort{13,24,5}.
        \end{equation}
        Sorting the rows gives
        \begin{equation}
            \ytableaushort{12,34,5}, \qqand \ytableaushort{13,24,5}.
        \end{equation}
        Hence, we have
        \begin{equation}
            \tilde{Y} = -\ytableaushort{12,34,5} - \ytableaushort{13,24,5}.
        \end{equation}
        
        Going back to our original tableau we can express \(Y\) as a sum of standard tableaux:
        \begin{align}
            Y &= - \ytableaushort{14,25,3} - \ytableaushort{14,23,5}\\
            &= -\ytableaushort{14,25,3} - \left( -\ytableaushort{12,34,5} - \ytableaushort{13,24,5} \, \right)\\
            &= -\ytableaushort{14,25,3} + \ytableaushort{12,34,5} + \ytableaushort{13,24,5}.
        \end{align}
        Notice that since the Young projectors, denoted here by the corresponding Young tableaux, are elements of an algebra, \(\complex[\symmetricGroup[5]]\), we can do all of the expected algebra with them such as distributing scalars over sums since \(\complex[\symmetricGroup[5]]\) is a vector space.
    \end{appendices}
    
    \backmatter
    %    \renewcommand{\glossaryname}{Acronyms}
    %    \printglossary[acronym]
    \printindex
\end{document}